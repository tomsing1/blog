{
  "hash": "c82d58d1b9646a60a0e05802ae48d717",
  "result": {
    "markdown": "---\ntitle: \"Adventures with parquet III: single-cell RNA-seq data and comparison with HDF5-backed arrays\"\nauthor: \"Thomas Sandmann\"\ndate: \"2023-09-13\"\nfreeze: true\ncategories: [R, TIL, parquet, Bioconductor]\neditor:\n  markdown:\n    wrap: 72\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    code-tools:\n      source: true\n      toggle: false\n      caption: none\neditor_options: \n  chunk_output_type: console\n---\n\n\n## tl;dr\n\nToday, I learned how to store single-cell RNA-seq data in a parquet file,\ncreated the `ParquetMatrix` class to retrieve them, and I started to compare\nthe performance of reading from parquet and HDF5 files.\n\n## Introduction\n\n[Previously](../parquetArray/), \nI learned how to create Bioconductor S4 objects based on parquet files. As\n[Aaron Lun pointed out](https://support.bioconductor.org/p/9154160/#9154171)\nParquet format is similar to 10X Genomics' HDF5 format for sparse matrices. This\nmotivated me to look into storing single-cell RNA-seq data, which is very sparse\nas most genes are not detected in any given cell.\n\nToday, I am experimenting with coercing data from parquet files into sparse\nmatrices and using them as a back-end for Hervé Pagès's great\n[DelayedArray S4 class](https://bioconductor.org/packages/release/bioc/html/DelayedArray.html).\nI used the awesome\n[HDF5Array package](https://bioconductor.org/packages/release/bioc/html/HDF5Array.html)\nto guide me, and learned more about arrow's `dictionary` type.\n\nIn the end, I was positively surprised that my crude `ParquetMatrix` class \nwas able to read either the full data matrix or a random subset of counts from\na parquet file even a little faster than from HDF5-backed original dataset.\n\nAs a bonus, `ParquetMatrix` objects can be instantiated from local parquet files\nor from cloud storage (S3).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(\"arrow\")\n  library(\"dplyr\")\n  library(\"fs\")\n  library(\"microbenchmark\")\n  library(\"rhdf5\")\n  library(\"tibble\")\n  library(\"tidyr\")\n  library(\"DelayedArray\")\n  library(\"Matrix\")\n  library(\"S4Vectors\")\n  library(\"SingleCellExperiment\")\n  library(\"TENxPBMCData\")\n})\n```\n:::\n\n\n## Retrieving an example Single-cell RNA-seq dataset\n\nAs an example dataset, I am using single-cell RNA-seq included as the `pbmc4k` \ndataset in the \n[TENxPBMCData Bioconductor package](https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html), with counts from \n[Peripheral Blood Mononuclear Cells (PBMCs)](https://www.ncbi.nlm.nih.gov/books/NBK500157/#top)\ncollected from a single donor. \n\nThe `TENxPBMCData()` function retrieves them from \n[ExperimentHub](https://bioconductor.org/packages/release/bioc/html/ExperimentHub.html)\nand caches them on the local system the first time the object is loaded [^1].\n\nIt downloads three files:\n\n- An HDF5 file with counts (dense assay)\n- An RDS file with row (= gene) annotations\n- An RDS file with column (= cell) annotations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntenx_pbmc4k <- suppressMessages(TENxPBMCData(dataset = \"pbmc4k\"))\ntenx_pbmc4k\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SingleCellExperiment \ndim: 33694 4340 \nmetadata(0):\nassays(1): counts\nrownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475\n  ENSG00000268674\nrowData names(3): ENSEMBL_ID Symbol_TENx Symbol\ncolnames: NULL\ncolData names(11): Sample Barcode ... Individual Date_published\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n:::\n:::\n\n\nThe `TENxPBMCData()` function combines counts with annotations, and returns\na `SingleCellExperiment` with a sparse HDF5-backed `DelayedMatrix` in\nthe `counts` slot and gene and cell annotations as `rowData` and `colData`\nDataFrames, respectively. It contains counts for 33694 genes\nin 4340 cells. \n\n[^1]: By default, the location of the cache is set via \n`ExperimentHub::getExperimentHubOption(\"CACHE\")`. For example, on my system the\ndata is located at /Users/sandmann/Library/Caches/org.R-project.R/R/ExperimentHub.\n\nThe counts are retrieved from the HDF5 file on demand, and the full matrix\nonly uses 2.3 Mb of\nmemory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts(tenx_pbmc4k)[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<10 x 10> sparse DelayedMatrix object of type \"integer\":\n                 [,1]  [,2]  [,3]  [,4] ...  [,7]  [,8]  [,9] [,10]\nENSG00000243485     0     0     0     0   .     0     0     0     0\nENSG00000237613     0     0     0     0   .     0     0     0     0\nENSG00000186092     0     0     0     0   .     0     0     0     0\nENSG00000238009     0     0     0     0   .     0     0     0     0\nENSG00000239945     0     0     0     0   .     0     0     0     0\nENSG00000239906     0     0     0     0   .     0     0     0     0\nENSG00000241599     0     0     0     0   .     0     0     0     0\nENSG00000279928     0     0     0     0   .     0     0     0     0\nENSG00000279457     0     0     0     0   .     0     0     0     1\nENSG00000228463     0     0     0     0   .     0     0     0     0\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\nThe underlying HDF5 file only contains the gene x cell count matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrhdf5::h5ls(path(counts(tenx_pbmc4k)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  group   name       otype  dclass          dim\n0     / counts H5I_DATASET INTEGER 33694 x 4340\n```\n:::\n:::\n\n\nThe \n\n:::\n\nLike most single-cell RNA-seq datasets, the data is very sparse:\nFor example, 97.5% of the\ngenes in the first four samples have zero counts. \n\n## Handling sparse count data in memory\n\nLet's load all counts into memory as a sparse `dgCMatrix` defined in the\n[Matrix R package](https://cran.r-project.org/package=Matrix).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- as(counts(tenx_pbmc4k), \"dgCMatrix\")\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33694  4340\n```\n:::\n:::\n\n\nBecause only non-zero counts need to be represented, the sparse `dgCMatrix`\nmatrix `m` is still relatively small, occupying \n67.9 Mb of memory.\n\n::: {.callout-note}\n\nInternally, a `dgCMatrix` is represented in the (sorted) \n[compressed sparse column format (CSC)](https://en.wikipedia.org/wiki/Sparse_matrix).\nEach non-zero value is stored as three numbers:\n\n- `i`: the row index\n- `j`: the column pointer\n- `x`: the value (= count)\n\n:::\n\nWe can extract this internal representation into a tall, thin data.frame with\nthe `Matrix::summary()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- as.data.frame(\n  Matrix::summary(\n    as(counts(tenx_pbmc4k), \"dgCMatrix\")\n  ), row.names = NULL\n)\ndf$x <- as.integer(df$x)\n```\n:::\n\n\nThis data.frame _only_ contains non-zero values, e.g. 19773 \nof the original 33694 genes and 4340 \nof the original 4340 cells. No counts were detected for the\nremaining (e.g. missing) genes and cells. \n\nThe data.frame requires 65.5 Mb of memory.\n\n::: {.callout-note collapse=\"true\"}\n\nInstead of a regular data.frame we can also work with `arrow::Table` objects.\nHere, I explicitly create a `Table` with three 32 bit integers. \n(Because single-cell RNA-seq counts are always positive and we have a good idea\nof their upper bound, I am using an unsigned 32 bit integer type for the `x`\ncolumn, allowing values between 0 and 4,294,967,295.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_tbl <- arrow::as_arrow_table(\n  df, \n  schema = arrow::schema(\n    i = int32(),\n    j = int32(),\n    x = uint32()\n  ))\na_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTable\n5727695 rows x 3 columns\n$i <int32>\n$j <int32>\n$x <uint32>\n\nSee $metadata for additional Schema metadata\n```\n:::\n:::\n\n\nCreating an `arrow::Table` object appears to consume little additional memory\n(0.5 Kb) as it is managed by `arrow` and\nnot R. \n\n:::\n\nAlternatively, I can also encode the row-names (= gene identifiers) and\ncolumn-names (= cell barcodes) in the data.frame. Because each of the \nidentifiers appears multiple times, they are best represented as factors. \n\nBy including _all_ of the gene- and barcode identifiers as factor levels,\nincluding those genes / barcodes that were not detected (e.g. had a total\nof zero counts), I retain information about them as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$i <- factor(row.names(tenx_pbmc4k)[df$i], levels = row.names(tenx_pbmc4k))\ndf$j = factor(tenx_pbmc4k$Barcode[df$j], levels = tenx_pbmc4k$Barcode)\n```\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\nBy the way, arrow tables (and parquet files) have an equivalent data type\nand R factors stored as type `dictionary`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrow::as_arrow_table(\n  df\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTable\n5727695 rows x 3 columns\n$i <dictionary<values=string, indices=int32>>\n$j <dictionary<values=string, indices=int16>>\n$x <int32>\n\nSee $metadata for additional Schema metadata\n```\n:::\n:::\n\n\n:::\n\n## Writing parquet files\n\nNext, let's store the `df` data.frame in a (single) parquet file on the\nlocal filesystem.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparquet_file <- tempfile(fileext = \".parquet\")\narrow::write_parquet(x = df, sink = parquet_file, use_dictionary = TRUE)\n```\n:::\n\n\nThis yields a parquet file that's 15.6M\nin size. (For comparison, the original HDF5 file was\n12.8M in size, but did\ncontained neither the gene- nor cel (=barcode) identifiers.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(arrow::read_parquet(parquet_file))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  i               j                      x\n  <fct>           <fct>              <int>\n1 ENSG00000187608 AAACCTGAGAAGGCCT-1     1\n2 ENSG00000116251 AAACCTGAGAAGGCCT-1     4\n3 ENSG00000177674 AAACCTGAGAAGGCCT-1     1\n4 ENSG00000117118 AAACCTGAGAAGGCCT-1     1\n5 ENSG00000179051 AAACCTGAGAAGGCCT-1     1\n6 ENSG00000053371 AAACCTGAGAAGGCCT-1     1\n```\n:::\n:::\n\n\n## A parquet-file backed DelayedArray\n\nThe original `tenx_pbmc4k` object represents the counts as a \n`sparse DelayedMatrix object of type \"integer\"`, e.g. it copies the data from\nthe HDF5 file into memory only when it is necessary.\n\nHere, I will reproduce this behavior with my parquet file by implementing a\nminimal seed for the `DelayedArray` S4 class.\n\n### The ParquetArraySeed S4 class \n\nUnder the hood, each `DelayedMatrix` object contains a _seed_ object. For\nexample, the `tenx_pbmc4k` object contains a `HDF5ArraySeed` seed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseed <- seed(counts(tenx_pbmc4k))\nclass(seed)\nis_sparse(seed)\n```\n:::\n\n\nLet's create a similar `ParquetArraySeed` class that inherits from the `Array`\nclass.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass(\"ParquetArraySeed\",\n    contains = \"Array\",\n    slots = c(\n        filepath = \"character\",\n        dim = \"integer\",\n        dimnames = \"list\"\n    )\n)\n```\n:::\n\n\nTo power a `DelayedArray` object, I need to define at least three different\nS4 methods for my new class:\n\n- `dim()` - returning an integer vector with the dimensions\n- `dimnames()` - returning a list of character vectors with the dimension names\n  (if any), e.g. the row and column names of the matrix.\n- `extract_array()` - returning an _ordinary array_ for a set of indices (see\n  below), e.g. a subset of the dataset to realize in memory.\n\nLet's start with the `dim()` and `dimnames()` methods. We will rely on the\nconstructor function (see below) to retrieve the unique row and column names\nfrom the parquet files, and then populate the `@dimnames` and `@dim` slots\nfor future reference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetMethod(\"dimnames\", \"ParquetArraySeed\", function(x) x@dimnames)\nsetMethod(\"dim\", \"ParquetArraySeed\", function(x) x@dim)\n```\n:::\n\n\nI also create a constructor function, which precalculates the dimensions of the\ndataset and populates the `@dim` and `@dimnames` slots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.get_dimnames <- function(filepath) {\n  list(\n    levels(read_parquet(filepath, col_select = \"i\")[[1]]),\n    levels(read_parquet(filepath, col_select = \"j\")[[1]])\n  )\n}\n.get_dim <- function(filepath) {\n  n_i <- read_parquet(filepath, col_select = \"i\") %>%\n    collect() %>%\n    pull(i) %>%\n    nlevels()\n  n_j <- read_parquet(filepath, col_select = \"j\") %>%\n    collect() %>%\n    pull(j) %>%\n    nlevels()\n  c(n_i, n_j)\n}\n\nParquetArraySeed <- function(filepath, dim = NULL, dimnames = NULL) {\n  if (is.null(dimnames)) {\n    dimnames <- .get_dimnames(filepath)\n  }\n  if (is.null(dim)) {\n    if (is.null(dimnames)) {\n      dim <- .get.dim(filepath)\n    } else {\n      dim <- lengths(dimnames)\n    }\n  }\n  x <- new(\"ParquetArraySeed\", filepath = filepath, dim = .get_dim(filepath), \n           dimnames = dimnames)\n  return(x)\n}\n```\n:::\n\n\nFinally, I need a function that subsets the dataset to a user-specified set of\ngenes and / or cells. I also need to ensure that passing an empty query returns\nthe full dataset. (In a [previous post](../parquetArray/) I used `duckdb` to\nqueries parquet files; here I am using arrow's `dplyr` bindings instead.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.extract_array_from_ParquetArraySeed <- function(x, index) {\n  if (identical(index, list(integer(0), integer(0)))) {\n    # zero indices => return empty matrix\n    return(matrix(0L, nrow = 0, ncol = 0))\n  } \n  keep_i <- seq.int(dim(x)[1])\n  keep_j <- seq.int(dim(x)[2])\n  \n  # to simplify lookups, I convert the arrow dictionary to integer indices \n  arrow_tbl <- read_parquet(x@filepath, as_data_frame = FALSE)\n  arrow_tbl$i <- Array$create(arrow_tbl$i)$indices() + 1\n  arrow_tbl$j <- Array$create(arrow_tbl$j)$indices() + 1\n  \n  if (is.null(index[[1]]) & is.null(index[[2]])) {\n  # NULL indices => return the full dataset\n    dataset <- arrow_tbl\n  } else if (!is.null(index[[1]]) && is.null(index[[2]])) {\n    # no column index => return all columns\n    keep_i <- index[[1]]\n    dataset <- filter(arrow_tbl, i %in% keep_i)\n  } else if (is.null(index[[1]]) && !is.null(index[[2]])) {\n    # no row index => return all rows\n    keep_j <- index[[2]]\n    dataset <- filter(arrow_tbl, j %in% keep_j)\n  } else {\n    # return requested rows and requested columns\n    keep_i <-index[[1]]\n    keep_j <- index[[2]]\n    dataset <- filter(arrow_tbl, i %in% keep_i, j %in% keep_j)\n  }\n  # pivot the count data into a matrix\n  dataset <- collect(dataset)\n  m <- matrix(\n    data = 0L,\n    nrow = length(keep_i),\n    ncol = length(keep_j),\n    dimnames = list(dimnames(x)[[1]][keep_i], \n                    dimnames(x)[[2]][keep_j])\n  )\n  matrix_index <- cbind(\n    match(dataset[[\"i\"]], keep_i),\n    match(dataset[[\"j\"]], keep_j)\n  )\n  m[matrix_index] <- dataset$x\n  return(m)\n}\n\nsetMethod(\"extract_array\", \"ParquetArraySeed\", \n          .extract_array_from_ParquetArraySeed)\n```\n:::\n\n\n## Creating a first parquet-backed DelayedArray object\n\nWith these three methods in place, I can instantiate my first `ParquetArraySeed`\nobject, which is suitable as input to the `DelayedArray` constructor from\nthe eponymous R package. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseed <- ParquetArraySeed(parquet_file)\nda <- DelayedArray(seed)\nclass(da)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"DelayedMatrix\"\nattr(,\"package\")\n[1] \"DelayedArray\"\n```\n:::\n:::\n\n\nNext, let's test different ways of subsetting our DelayedArray and make sure\nthe returned dimensions match those of the requested indices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(\n  identical(dim(da[1:10, 1:100]), c(10L, 100L)),\n  identical(dim(da[1:10, ]), c(10L, ncol(da))),\n  identical(dim(da[, 1:10]), c(nrow(da), 10L)),\n  identical(dim(da[\"ENSG00000243485\", 1:10, drop = FALSE]), c(1L, 10L)),\n  identical(\n    dim(da[c(1, 1, 2, 98), c(\"AACTCAGTCCAACCAA-1\", \"AACTCCCAGAAACCTA-1\")]),\n  c(4L, 2L))\n)\n```\n:::\n\n\nFinally, let's retrieve the (raw) counts for the GAPDH gene (`ENSG00000111640`)\nand ensure that the same results are retrieved from both objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(\n  counts(tenx_pbmc4k[ \"ENSG00000111640\", ]), \n  da[ \"ENSG00000111640\", tenx_pbmc4k$Barcode],\n  xlab = \"GAPDH (ParquetArray)\", ylab = \"GAPDH (SingleCellExperiment)\")\nabline(0, 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=384}\n:::\n:::\n\n\n### The ParquetMatrix class\n\nNow that I have defined a _seed_, I can add a higher level class to\nfacilitate working with parquet-backed matrices. The `ParquetMatrix` inherits\nfrom the `DelayedMatrix` class. It will automatically create the necessary\n_seed_, so all I have to provide is the path to the parquet file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass(\"ParquetMatrix\",\n    contains = \"DelayedMatrix\",\n    representation(seed = \"ParquetArraySeed\")\n)\n\nsetMethod(\"DelayedArray\", \"ParquetArraySeed\",\n    function(seed) new_DelayedArray(seed, Class=\"ParquetMatrix\")\n)\n\nParquetMatrix <- function(filepath, ...) {\n  seed <- ParquetArraySeed(filepath = filepath, ...)\n  new(\"ParquetMatrix\", seed = seed)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npm <- ParquetMatrix(parquet_file)\ndim(pm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33694  4340\n```\n:::\n:::\n\n\nAs I learned \n[in a previous post](../parquetArray/#creating-a-parquet-backed-summarizedexperiment)\ngene and cell annotations can be combined with the `ParquetMatrix`\ninto a `SingleCellExperiment`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- SingleCellExperiment(\n  assays = list(counts = pm),\n  colData = colData(tenx_pbmc4k)[match(colnames(pm), tenx_pbmc4k$Barcode), ],\n  rowData = rowData(tenx_pbmc4k)[row.names(pm), ]\n)\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SingleCellExperiment \ndim: 33694 4340 \nmetadata(0):\nassays(1): counts\nrownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475\n  ENSG00000268674\nrowData names(3): ENSEMBL_ID Symbol_TENx Symbol\ncolnames(4340): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ...\n  TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1\ncolData names(11): Sample Barcode ... Individual Date_published\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n:::\n:::\n\n\n## Comparison to HDF5-backed DelayedArrays\n\nLet's finish this example of a minimal implementation of the `ParquetMatrix`\nclass by comparing its performance with the original hdf5-backed object.\n\n### Reading the full dataset into memory\n\nFirst, let's read the full matrix into memory from either our parquet or the\noriginal HDF5 files. (We read each file ten times to get an idea of the \naverage time it takes on my system.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmb <- microbenchmark(\n    parquet = as.matrix(counts(sce)),\n    hdf5 = as.matrix(counts(tenx_pbmc4k)),\n  times = 10, unit = \"s\")\nprint(mb, signif = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: seconds\n    expr  min   lq mean median   uq  max neval\n parquet 0.54 0.57 0.59   0.58 0.61 0.65    10\n    hdf5 0.81 0.82 0.85   0.83 0.86 0.94    10\n```\n:::\n:::\n\n\nNot too bad! Loading the count matrix into memory from the parquet file is\nslightly faster than from the HDF5 file on average.\n\n### Subsetting to 50 random rows and columns\n\nBoth parquet and HDF5 formats are optimized for column-oriented data. Let's try\nto retrieve a random subset of counts to see how they fare:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrows <- sample(nrow(pm), 50, replace = FALSE)\ncols <- sample(ncol(pm), 50, replace = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmb <- microbenchmark(\n    parquet = as.matrix(counts(sce)[rows, cols]),\n    hdf5 = as.matrix(counts(tenx_pbmc4k)[rows, cols]),\n  times = 10, unit = \"s\")\nprint(mb, signif = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: seconds\n    expr   min    lq mean median   uq  max neval\n parquet 0.093 0.095 0.11   0.11 0.12 0.14    10\n    hdf5 0.120 0.120 0.12   0.12 0.12 0.12    10\n```\n:::\n:::\n\n\nExtracting the 50 x 50 sub-matrix takes roughly the same amount of time with\nboth file types.\n\n## Conclusion\n\nToday, I learned a lot about working with arrow objects in R, and got the\nchance to explore the `DelayedArray` infrastructure further. I am certain that\nthe methods I wrote can be improved - but even my crude implementation of the \n`ParquetMatrix` class seems to be about  as performant as the HDF5-backed\nversion when reading from a local file.\n\nThe arrow project supports reading parquet files from cloud storage (S3),\nsomething I found challenging (e.g. slow) with HDF5 files. All I need to do\nis pass an S3 URL as the `filepath` argument to the `ParquetMatrix()`\nfunction, and (assuming I have set up the right access credentials) I can work\nwith remote files in the same way.[^2]\n\n[^2]: The performance will depend on the network connection. With my home\ninternet connection, I was able to read the full dataset from the parquet file \ninto memory or extract counts for 50 random genes x cells in 1.8 seconds on\naverage.\n\n## Reproducibility\n\n<details>\n<summary>\nSession Information\n</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info(\"attached\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Ventura 13.5.2\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Los_Angeles\n date     2023-09-13\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package              * version date (UTC) lib source\n P abind                * 1.4-5   2016-07-21 [?] CRAN (R 4.3.0)\n P arrow                * 13.0.0  2023-08-30 [?] CRAN (R 4.3.0)\n P Biobase              * 2.60.0  2023-05-08 [?] Bioconductor\n P BiocGenerics         * 0.46.0  2023-06-04 [?] Bioconductor\n P DelayedArray         * 0.26.7  2023-07-30 [?] Bioconductor\n P dplyr                * 1.1.2   2023-04-20 [?] CRAN (R 4.3.0)\n P fs                   * 1.6.3   2023-07-20 [?] CRAN (R 4.3.0)\n P GenomeInfoDb         * 1.36.1  2023-07-02 [?] Bioconductor\n P GenomicRanges        * 1.52.0  2023-05-08 [?] Bioconductor\n P HDF5Array            * 1.28.1  2023-05-08 [?] Bioconductor\n P IRanges              * 2.34.1  2023-07-02 [?] Bioconductor\n P Matrix               * 1.5-4.1 2023-05-18 [?] CRAN (R 4.3.1)\n P MatrixGenerics       * 1.12.3  2023-07-30 [?] Bioconductor\n P matrixStats          * 1.0.0   2023-06-02 [?] CRAN (R 4.3.0)\n P microbenchmark       * 1.4.10  2023-04-28 [?] CRAN (R 4.3.0)\n P rhdf5                * 2.44.0  2023-05-08 [?] Bioconductor\n P S4Arrays             * 1.0.6   2023-08-30 [?] Bioconductor\n P S4Vectors            * 0.38.1  2023-05-08 [?] Bioconductor\n P SingleCellExperiment * 1.22.0  2023-05-08 [?] Bioconductor\n P SummarizedExperiment * 1.30.2  2023-06-11 [?] Bioconductor\n P TENxPBMCData         * 1.18.0  2023-04-27 [?] Bioconductor\n P tibble               * 3.2.1   2023-03-20 [?] CRAN (R 4.3.0)\n P tidyr                * 1.3.0   2023-01-24 [?] CRAN (R 4.3.0)\n\n [1] /Users/sandmann/repositories/blog/renv/library/R-4.3/aarch64-apple-darwin20\n [2] /Users/sandmann/Library/Caches/org.R-project.R/R/renv/sandbox/R-4.3/aarch64-apple-darwin20/ac5c2659\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>\n   ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}