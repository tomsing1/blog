{
  "hash": "335cc426267bae6beb84401d411cebac",
  "result": {
    "markdown": "---\ntitle: \"Experimenting with SQLite: storing gene set collections\"\nauthor: \"Thomas Sandmann\"\ndate: \"2022-12-30\"\nfreeze: true\ncategories: [TIL, R, databases]\neditor:\n  markdown:\n    wrap: 72\nformat:\n  html:\n    code-tools:\n      source: true\n      toggle: false\n      caption: none\neditor_options: \n  chunk_output_type: inline\n---\n\n\n## Gene set collection & SQLite\n\nIn this document, I explore different approaches to store a gene set collection\n(e.g. the \n[MSigDb hallmark gene sets (MH)](http://www.gsea-msigdb.org/gsea/msigdb/mouse/genesets.jsp?collection=MH)\n)\nin a relational database.\n\nBioconductor offers well designed S4 Classes to store gene set collections, \nincluding e.g. in a list-like\n[GSEABase::GeneSetCollection](https://bioconductor.org/packages/release/bioc/html/GSEABase.html)\nor a set of three `tibbles` within a\n[BiocSet::BiocSet](https://bioconductor.org/packages/release/bioc/html/BiocSet.html)\nobject. \n**So why could we be interested in storing this information in a database?**\n\n- A database (e.g. SQLite, Postgres, etc) offers a highly standardized way to\nstore and manage information in a *language-agnostic* way. E.g. some of my \ncolleagues use python for their analyses and are comfortable retrieving gene\nset information from a database, but not necessarily from an R S4 object.\n- Gene sets capture knowledge from multiple experiments, studies and sources.\nIf you are part of a larger organization a single *source of truth*, available\nin a central location, is very useful.\n- Collaborators might not be interested / able to access information\nprogrammatically, e.g. they may prefer a web application to search, share and\nedit gene sets. Many tools to build web applications have built-in \ncapabilities to interact with a database.\n- As the number of gene sets grows, sharing them in the form of one or more\nfiles might become cumbersome. A hosted database (e.g. \n[Postgres](https://www.postgresql.org/)\nor\n[MariaDB](https://mariadb.org/)\n) allows users to retrieve only the information they need.\n\nHere, I am using the \n[SQLite](https://www.sqlite.org/index.html)\nengine to explore *both* relational and non-relational ways to manage gene sets. \n`SQLite` can be embedded into applications, and does not require a central\nserver, making it ideal for experimentation. (But as you move into a scenario\nwhere multiple users need to access a central, it is time to switch to a hosted\ndatabase instead; my favorite is [Postgres](https://www.postgresql.org/).)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(BiocSet)\nlibrary(dplyr)\nlibrary(here)\nlibrary(jsonlite)\nlibrary(nodbi)\nlibrary(org.Mm.eg.db)\nlibrary(purrr)\nlibrary(RSQLite)\nlibrary(tibble)\nlibrary(tidyr)\n```\n:::\n\n\n## The Mouse Hallmarks MSigDB collection\n\nAt the time of writing, \n[Mouse Molecular Signatures Database (MSigDB)](https://www.gsea-msigdb.org/gsea/msigdb/mouse/collections.jsp?targetSpeciesDB=Mouse)\ncontains 15918 gene sets, organized into numerous different collections. For\nexample, the 50\n[hallmark gene sets (MH)](http://www.gsea-msigdb.org/gsea/msigdb/mouse/genesets.jsp?collection=MH)\nsummarize and represent specific well-defined biological states or processes (\n[Liberzon et al, 2015](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4707969/)\n). \n\n\n\n\n\n\n::: {.callout-note}\n\nEach of the 50 sets in the collection contains between \n32 and\n200 official\n[gene symbols](https://rosalind.info/glossary/gene-symbol/), specifing the\nmembers of the gene set.\n\n:::\n\nHere, I will use the hallmarks collection as an example but the overall approach\ncan be applied to other gene set collection in a similar way. (You might need\nadditional / different annotation fields, though.)\n\nThe mouse hallmarks collection is available (after logging into the MSigDb\nwebsite) in different formats, including as a JSON file. Here, I have read it \ninto my R session as the nested list `mh`.\n\nEach of the 50 elements in the JSON file corresponds to a different\ngene set,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(names(mh))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"HALLMARK_ADIPOGENESIS\"        \"HALLMARK_ALLOGRAFT_REJECTION\"\n[3] \"HALLMARK_ANDROGEN_RESPONSE\"   \"HALLMARK_ANGIOGENESIS\"       \n[5] \"HALLMARK_APICAL_JUNCTION\"     \"HALLMARK_APICAL_SURFACE\"     \n```\n:::\n:::\n\neach gene set is a nested list with the following elements,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlengths(mh[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              systematicName                         pmid \n                           1                            1 \n                 exactSource                  geneSymbols \n                           1                          200 \n                   msigdbURL           externalDetailsURL \n                           1                            1 \n        filteredBySimilarity externalNamesForSimilarTerms \n                           0                            0 \n                  collection \n                           1 \n```\n:::\n:::\n\n\nand the gene symbols that make up the set are listed in the `geneSymbols` \nsublist:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mh[[1]]$geneSymbols)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Abca1\" \"Abcb8\" \"Acaa2\" \"Acadl\" \"Acadm\" \"Acads\"\n```\n:::\n:::\n\n\n## noSQL: storing gene sets as unstructured documents\n\nEach gene set is represented as a list - so why not store it in the same\nway? A\n[noSQL](https://en.wikipedia.org/wiki/NoSQL)\ndatabase is designed to store unstructed information, e.g. data models that are \nnot organized in tables, making them flexible and scalable. \nExamples of `noSQL` databases include e.g.\n[Mongodb](https://www.mongodb.com/),\n[CouchDB](https://couchdb.apache.org/)\nor\n[AWS dynamodb](https://en.wikipedia.org/wiki/Amazon_DynamoDB).\n\nIn addition, traditional relational database engines - including `SQLite` and\n`Postgres` can also store unstructured data in dedicated `JSON` fields.\n\nThe\n[nodbi R package](https://docs.ropensci.org/nodbi/)\nprovides a unified interface to multiple `noSQL` implementations, including \n`SQLite`. (If you are interested in a deeper look at how to create & query \na JSON field in SQLite with raw SQL, check out\n[this gist](https://gist.github.com/tomsing1/304762fce66353310b254e8b22094a6e)\n).\n\n### Creating & populating a noSQL database with the `nodbi` R package\n\nTo experiment with its `noSQL` mode, we create a temporary `SQLite` database in\nmemory. (For real data, you definitely want to provide a file path as the \n`dbname` instead!) \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrc <- nodbi::src_sqlite(dbname = \":memory:\")\n```\n:::\n\n\nRight now, the names of the gene sets are only stored as the `names()` of the\nlist elements, e.g. not in a field _within_ each sub-list itself. To make sure\nthey are included in each database record, we add them to each sub-list in a new\n`name` field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmh2 <- lapply(names(mh), \\(gs) c(\"name\" = gs, mh[[gs]]))\n```\n:::\n\n\n::: {.callout-note}\nThe `docdb_create()` function accepts either  a data.frame, a JSON string or a\nlist as its `value` argument.\n\nIf you include a field `_id` in your list, it will be used as the primary key\nfor each element. If no `_id` field is found, then the `_id` field is created\nautomatically with a call to the `uuid::UUIDgenerate()` function.\n\nIf you provide a `data.frames()` with row.names, they will be used to populate \nthe `_id` field.\n:::\n\nNow we are ready to create a new SQLite table `hallmarks` and populate it with\nthe  50 gene sets. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndocdb_create(src, key = \"hallmarks\", value = mh2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50\n```\n:::\n:::\n\nWe can retrieve the full set of records as a `data.frame` with the `docdb_get()`\nfunction. (Here we select a subset of the returned columns due to space \nconstraints.) Because each gene set contains multiple `geneSymbols`, this field\nis a list-column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndocdb_get(src, \"hallmarks\")[1:4, c(\"name\", \"geneSymbols\", \"pmid\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          name  geneSymbols     pmid\n1        HALLMARK_ADIPOGENESIS Abca1, A.... 30224793\n2 HALLMARK_ALLOGRAFT_REJECTION Aars, Ab.... 30224793\n3   HALLMARK_ANDROGEN_RESPONSE Abcc4, A.... 30224793\n4        HALLMARK_ANGIOGENESIS Apoh, Ap.... 30224793\n```\n:::\n:::\n\n### Querying with JSON filters\n\nMore commonly, users might want to retrieve one or more gene sets by name.\nThe `docdb_query()` function accepts a `query` argument specifying the\ndesired filter criteria (as \n[MongoDB JSON](https://www.mongodb.com/docs/manual/tutorial/query-documents/#specify-equality-condition)\n).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- nodbi::docdb_query(\n  src = src, key = \"hallmarks\",\n  query = '{\"name\": \"HALLMARK_ADIPOGENESIS\"}')\nresults[, c(\"name\", \"geneSymbols\", \"pmid\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   name  geneSymbols     pmid\n1 HALLMARK_ADIPOGENESIS Abca1, A.... 30224793\n```\n:::\n:::\n\n\nThe `fields` argument allows us to return only specific columns. (Specifying a \nfield as `1` or `0` will include or exclude it, respectively.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodbi::docdb_query(\n  src = src, key = \"hallmarks\",\n  query = '{\"name\": \"HALLMARK_ADIPOGENESIS\"}',\n  fields = '{\"name\": 1, \"geneSymbols\": 1}'\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   name  geneSymbols\n1 HALLMARK_ADIPOGENESIS Abca1, A....\n```\n:::\n:::\n\n\nWe can also identify gene sets containing at least one of the given gene\nsymbols:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- nodbi::docdb_query(\n  src = src, key = \"hallmarks\",\n  query = paste0('{\"$or\":[',\n                 '{\"geneSymbols\": \"Abca1\"},', \n                 '{\"geneSymbols\": \"Gapdh\"}',\n                 ']}'),\n  fields = '{\"name\": 1, \"geneSymbols\": 1}'\n)\n```\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n\nBecause the set contains more than one `geneSymbol`, we obtain a nested\ndata.frame. We can unnest it e.g. with the `tidyr` R package\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::unnest(results, cols = c(geneSymbols))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 798 × 2\n   name                  geneSymbols\n   <chr>                 <chr>      \n 1 HALLMARK_ADIPOGENESIS Abca1      \n 2 HALLMARK_ADIPOGENESIS Abcb8      \n 3 HALLMARK_ADIPOGENESIS Acaa2      \n 4 HALLMARK_ADIPOGENESIS Acadl      \n 5 HALLMARK_ADIPOGENESIS Acadm      \n 6 HALLMARK_ADIPOGENESIS Acads      \n 7 HALLMARK_ADIPOGENESIS Acly       \n 8 HALLMARK_ADIPOGENESIS Aco2       \n 9 HALLMARK_ADIPOGENESIS Acox1      \n10 HALLMARK_ADIPOGENESIS Adcy6      \n# … with 788 more rows\n```\n:::\n:::\n\n:::\n\n### Querying using SQL\n\nFormulating the queries as JSON strings is tedious, though. Alternatively,\nSQLite also supports querying JSON columns using SQL (muddying the border\nbetween `noSQL` and `SQL`). Specifically, we can use SQLite's \n[-> and ->> operators](https://www.sqlite.org/json1.html#jptr) and the \n`json_each()` SQL function to create a query that returns the names of all gene\nsets that include the `Abca1` gene:\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT hallmarks.json->>'name' as name\nFROM hallmarks, json_each(hallmarks.json, '$.geneSymbols')\nWHERE json_each.value LIKE '%Abca1%'\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 5 records\n\n|name                             |\n|:--------------------------------|\n|HALLMARK_ADIPOGENESIS            |\n|HALLMARK_BILE_ACID_METABOLISM    |\n|HALLMARK_INFLAMMATORY_RESPONSE   |\n|HALLMARK_PROTEIN_SECRETION       |\n|HALLMARK_TNFA_SIGNALING_VIA_NFKB |\n\n</div>\n:::\n\n\n\n\nDepending on comfortable you are reading / writing SQL, this might be a nicer\napproach. \n\n::: {.callout-note}\nSQLite's JSON operators are somewhat limited, e.g. there is no straightforward\nway to ask whether a column _contains_ one or more gene identifiers (e.g. the\nquery we performed above using a query JSON string). Indexing a SQLite JSON\ncolumn also comes with limitations. \n\nThe Postgres database engine \n[supports JSON and binary JSONB fields)](https://www.postgresql.org/docs/current/functions-json.html) \nwith indexing & additional operators like the `@>` contains operator.\n:::\n\n### noSQL summary\n\nThis example highlights some of the advantages of a noSQL solution:\n\n- Rapid ingestion of data without the need for a rigid schema.\n- Simple retrieval of individual object identified by their primary key.\n\nBut also some of the disadvantages:\n\n- Queries that descend into the (potentially nested) objects must be carefully\nconstructed.\n- Increasing database performance with indices is more complicated than for \nrelational databases (see below.)\n\nNext, we will try another approach: reshaping the gene set collection into a set\nof tables and modeling the relationship between them.s\n\n## SQL: storing gene sets in a relational database\n\nTo take advantage of a \n[relational database](https://en.wikipedia.org/wiki/Relational_database),\nwe have perform a little more work up-front. But this effort is repaid by \nsimplifying subsequent queries.\n\n### Learning from Bioconductor: BiocSet's three tables\n\nThe `BiocSet` Class from the eponymous Bioconductor package represents a \ncollection of gene sets in three tibbles. Let's create a simple `BiocSet` with\ntwo gene sets for illustration:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_names <- purrr::map_chr(mh2[1:2], \"name\")\ngene_ids <- purrr::map(mh2[1:2], \"geneSymbols\")\nes <- BiocSet(setNames(gene_ids, set_names))\n```\n:::\n\n\nThe first two tibbles represent genes (called `elements`) and `sets`, \nrespectively:\n\n1. `es_element`: one row per gene\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(es_element(es))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  element\n  <chr>  \n1 Abca1  \n2 Abcb8  \n3 Acaa2  \n4 Acadl  \n5 Acadm  \n6 Acads  \n```\n:::\n:::\n\n\n2. `es_set`: one row per gene set\n\n\n::: {.cell}\n\n```{.r .cell-code}\nes_set(es)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 1\n  set                         \n  <chr>                       \n1 HALLMARK_ADIPOGENESIS       \n2 HALLMARK_ALLOGRAFT_REJECTION\n```\n:::\n:::\n\n\nThe third table establishes the many-to-many relationship between genes and\nsets.\n\n3. `es_elementset`: gene x set combination\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we are showing 10 random rows\nset.seed(42)\nes_elementset(es)[sample(nrow(es_elementset(es)), size = 10), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   element set                         \n   <chr>   <chr>                       \n 1 Coq5    HALLMARK_ADIPOGENESIS       \n 2 Irf7    HALLMARK_ALLOGRAFT_REJECTION\n 3 Qdpr    HALLMARK_ADIPOGENESIS       \n 4 Elovl6  HALLMARK_ADIPOGENESIS       \n 5 Cd28    HALLMARK_ALLOGRAFT_REJECTION\n 6 Ppm1b   HALLMARK_ADIPOGENESIS       \n 7 Mtarc2  HALLMARK_ADIPOGENESIS       \n 8 Zap70   HALLMARK_ALLOGRAFT_REJECTION\n 9 Ndufb7  HALLMARK_ADIPOGENESIS       \n10 Il15    HALLMARK_ALLOGRAFT_REJECTION\n```\n:::\n:::\n\n\nEach of these tables can be augmented with additional metadata, e.g. we could\nadd \n[Entrez](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1761442/)\ngene identifiers to the `es_element`, or a long-formdescriptions for each set to\nthe `es_set` tibble.\n\nThese three tables can also be represented in a relational database, using\nthe `element` and `set` columns as primary keys.\n\n### Creating and populating a relational database\n\nLet's start with a fresh SQLite database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- dbConnect(RSQLite::SQLite(), \":memory:\")\n```\n:::\n\n\nFirst, we create the `geneset` data.frame that lists all gene sets, and we also\ninclude their MSigDb URLs as metadata:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeneset <- data.frame(\n  geneset = purrr::map_chr(mh2, \"name\"),\n  url = purrr::map_chr(mh2, \"msigdbURL\"))\nhead(geneset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       geneset\n1        HALLMARK_ADIPOGENESIS\n2 HALLMARK_ALLOGRAFT_REJECTION\n3   HALLMARK_ANDROGEN_RESPONSE\n4        HALLMARK_ANGIOGENESIS\n5     HALLMARK_APICAL_JUNCTION\n6      HALLMARK_APICAL_SURFACE\n                                                                                 url\n1        https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HALLMARK_ADIPOGENESIS\n2 https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HALLMARK_ALLOGRAFT_REJECTION\n3   https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HALLMARK_ANDROGEN_RESPONSE\n4        https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HALLMARK_ANGIOGENESIS\n5     https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HALLMARK_APICAL_JUNCTION\n6      https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HALLMARK_APICAL_SURFACE\n```\n:::\n:::\n\n\nNext, we identify all unique gene symbols, annotate them with their Entrez ids\n(using the\n[org.Mm.eg.db Bioconductor annotation package](https://bioconductor.org/packages/release/data/annotation/html/org.Mm.eg.db.html)\n), and store both identifier types in the `element` data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_symbols <- unique(unlist(purrr::map(mh2, \"geneSymbols\")))\nelement <- data.frame(\n  element = gene_symbols,\n  entrezid = mapIds(org.Mm.eg.db, keys = gene_symbols, keytype = \"SYMBOL\", \n                    column = \"ENTREZID\")\n  )\nhead(element)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      element entrezid\nAbca1   Abca1    11303\nAbcb8   Abcb8    74610\nAcaa2   Acaa2    52538\nAcadl   Acadl    11363\nAcadm   Acadm    11364\nAcads   Acads    11409\n```\n:::\n:::\n\n\nand finally the `element_set` join table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelementset <- purrr::map_df(mh2, \\(gs) {\n  with(gs, \n       data.frame(\n         element = geneSymbols,\n         geneset = name\n       )\n  )\n})\nhead(elementset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  element               geneset\n1   Abca1 HALLMARK_ADIPOGENESIS\n2   Abcb8 HALLMARK_ADIPOGENESIS\n3   Acaa2 HALLMARK_ADIPOGENESIS\n4   Acadl HALLMARK_ADIPOGENESIS\n5   Acadm HALLMARK_ADIPOGENESIS\n6   Acads HALLMARK_ADIPOGENESIS\n```\n:::\n:::\n\n\nNext, we write each data.frame into a separate table in our SQLite database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con, \n          \"CREATE TABLE tbl_geneset (geneset TEXT PRIMARY KEY, url TEXT)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbWriteTable(con, name = \"tbl_geneset\", value = geneset, overwrite = TRUE)\n\ndbExecute(con, \n          \"CREATE TABLE tbl_element (element TEXT PRIMARY KEY, entrezid TEXT)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbWriteTable(con, name = \"tbl_element\", value = element, overwrite = TRUE)\n\ndbExecute(con, paste(\n  \"CREATE TABLE tbl_elementset (\",\n  \"element TEXT,\", \n  \"geneset TEXT,\",\n  \"FOREIGN KEY(geneset) REFERENCES tbl_geneset(geneset),\",\n  \"FOREIGN KEY(element) REFERENCES tbl_element(element)\",\n  \")\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbWriteTable(con, name = \"tbl_elementset\", value = elementset, overwrite = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_element\"    \"tbl_elementset\" \"tbl_geneset\"   \n```\n:::\n:::\n\n\n### Querying the database\n\nGreat! Now we are ready to query our databse. To make our lives easier, we will\nuse the \n[dplyr](https://cran.r-project.org/package=dplyr)\npackage to translate our R syntax into SQL. First we define the remote tables\nby connecting to our brand new database:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_geneset <- tbl(con, \"tbl_geneset\")\ntbl_element <- tbl(con, \"tbl_element\")\ntbl_elementset <- tbl(con, \"tbl_elementset\")\n```\n:::\n\n\nLet's return the gene symbols and entrez identifiers that make up the \n`HALLMARK_APOPTOSIS` gene set and display the first 5 (in alphabetical order of\nthe gene symbols).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- tbl_elementset %>% \n  dplyr::filter(geneset == \"HALLMARK_ADIPOGENESIS\") %>%\n  dplyr::inner_join(tbl_element, by = \"element\") %>%\n  dplyr::slice_min(n = 5, order_by = element)\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [5 x 3]\n# Database: sqlite 3.39.4 [:memory:]\n  element geneset               entrezid\n  <chr>   <chr>                 <chr>   \n1 Abca1   HALLMARK_ADIPOGENESIS 11303   \n2 Abcb8   HALLMARK_ADIPOGENESIS 74610   \n3 Acaa2   HALLMARK_ADIPOGENESIS 52538   \n4 Acadl   HALLMARK_ADIPOGENESIS 11363   \n5 Acadm   HALLMARK_ADIPOGENESIS 11364   \n```\n:::\n:::\n\n\nAnd now let's add the gene set's URL as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult %>%\n  dplyr::left_join(tbl_geneset, by = \"geneset\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [5 x 4]\n# Database: sqlite 3.39.4 [:memory:]\n  element geneset               entrezid url                                    \n  <chr>   <chr>                 <chr>    <chr>                                  \n1 Abca1   HALLMARK_ADIPOGENESIS 11303    https://www.gsea-msigdb.org/gsea/msigd…\n2 Abcb8   HALLMARK_ADIPOGENESIS 74610    https://www.gsea-msigdb.org/gsea/msigd…\n3 Acaa2   HALLMARK_ADIPOGENESIS 52538    https://www.gsea-msigdb.org/gsea/msigd…\n4 Acadl   HALLMARK_ADIPOGENESIS 11363    https://www.gsea-msigdb.org/gsea/msigd…\n5 Acadm   HALLMARK_ADIPOGENESIS 11364    https://www.gsea-msigdb.org/gsea/msigd…\n```\n:::\n:::\n\n\n### Pulling data into a BiocSet\n\nFinally, we can easily pull selected (or even all) gene sets into a Bioconductor\n`BiocSet` object for analysis in R. (But the database does _not require_ us to\nuse R, e.g. python users can connect to the same SQLite database and retrieve\nthe information in a form that is most useful to them.)\n\nFor example, let's retrieve all gene sets whose name ends in the letter `N`,\nstore them in a list and create a `BiocSet` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_set_list <- with(\n  tbl_elementset %>% \n    dplyr::filter(geneset %like% '%N') %>%\n    collect(), \n  split(element, geneset)\n)\nes <- BiocSet(gene_set_list)\n```\n:::\n\n\nNext, we add gene set metadata to the `es_set` tibble, by joining it with the\n(richer) information in the database. This will add the `url` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nes <- left_join_set(es, \n  tbl_geneset, by = c(set = \"geneset\"), \n  copy = TRUE\n)\nes_set(es)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 2\n  set                                        url                                \n  <chr>                                      <chr>                              \n1 HALLMARK_ALLOGRAFT_REJECTION               https://www.gsea-msigdb.org/gsea/m…\n2 HALLMARK_APICAL_JUNCTION                   https://www.gsea-msigdb.org/gsea/m…\n3 HALLMARK_COAGULATION                       https://www.gsea-msigdb.org/gsea/m…\n4 HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION https://www.gsea-msigdb.org/gsea/m…\n5 HALLMARK_KRAS_SIGNALING_DN                 https://www.gsea-msigdb.org/gsea/m…\n6 HALLMARK_OXIDATIVE_PHOSPHORYLATION         https://www.gsea-msigdb.org/gsea/m…\n7 HALLMARK_PROTEIN_SECRETION                 https://www.gsea-msigdb.org/gsea/m…\n8 HALLMARK_UV_RESPONSE_DN                    https://www.gsea-msigdb.org/gsea/m…\n```\n:::\n:::\n\n\nAnd finally, let's also add the `entrezid` column from out database \nto the `es_element` table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nes <- left_join_element(es, \n  tbl_element, by = \"element\", \n  copy = TRUE\n)\nes_element(es)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,233 × 2\n   element entrezid\n   <chr>   <chr>   \n 1 Aars    234734  \n 2 Abce1   24015   \n 3 Abi1    11308   \n 4 Ache    11423   \n 5 Acvr2a  11480   \n 6 Akt1    11651   \n 7 Apbb1   11785   \n 8 B2m     12010   \n 9 Bcat1   12035   \n10 Bcl10   12042   \n# … with 1,223 more rows\n```\n:::\n:::\n\n### SQL summary\n\n- For this example the effort required to transform the dataset into a set of\nthree tables - the starting point for import into a relational database - was \nminimal. \n- Given the use case, e.g. management of a gene set collections, the number of\ntimes that data is added to the database is likely much smaller than the number \nof times it is queried. That makes it worth the effort to transform it once - \nand benefit from this upfront cost ever after.\n- Because we knew exactly which properties / annotations we wanted to capture\nin the database, defining the database tables and their relationships (e.g. the\n[schema](https://en.wikipedia.org/wiki/Database_schema)\n) was not an obstacle, either.\n- Enabling users to query the data using simple SQL or via a higher level\nabstraction like `dplyr` makes it accessible to a broader audience.\n\n::: {.callout-warn}\n\nDefining a schema is much harder when we deal with datasets that are less\nstandardized, changing over time, etc.\n\n:::\n\n<details>\n<summary>\nSessionInfo\n</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31)\n os       macOS Big Sur ... 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Los_Angeles\n date     2022-12-31\n pandoc   2.19.2 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version  date (UTC) lib source\n AnnotationDbi    * 1.60.0   2022-11-01 [1] Bioconductor\n askpass            1.1      2019-01-13 [1] CRAN (R 4.2.0)\n assertthat         0.2.1    2019-03-21 [1] CRAN (R 4.2.0)\n Biobase          * 2.58.0   2022-11-01 [1] Bioconductor\n BiocGenerics     * 0.44.0   2022-11-01 [1] Bioconductor\n BiocIO             1.8.0    2022-11-01 [1] Bioconductor\n BiocSet          * 1.12.0   2022-11-01 [1] Bioconductor\n Biostrings         2.66.0   2022-11-01 [1] Bioconductor\n bit                4.0.5    2022-11-15 [1] CRAN (R 4.2.0)\n bit64              4.0.5    2020-08-30 [1] CRAN (R 4.2.0)\n bitops             1.0-7    2021-04-24 [1] CRAN (R 4.2.0)\n blob               1.2.3    2022-04-10 [1] CRAN (R 4.2.0)\n cachem             1.0.6    2021-08-19 [1] CRAN (R 4.2.0)\n cli                3.5.0    2022-12-20 [1] CRAN (R 4.2.0)\n crayon             1.5.2    2022-09-29 [1] CRAN (R 4.2.0)\n credentials        1.3.2    2021-11-29 [1] CRAN (R 4.2.0)\n DBI                1.1.3    2022-06-18 [1] CRAN (R 4.2.0)\n dbplyr             2.2.1    2022-06-27 [1] CRAN (R 4.2.0)\n digest             0.6.31   2022-12-11 [1] CRAN (R 4.2.0)\n dplyr            * 1.0.10   2022-09-01 [1] CRAN (R 4.2.0)\n ellipsis           0.3.2    2021-04-29 [1] CRAN (R 4.2.0)\n evaluate           0.19     2022-12-13 [1] CRAN (R 4.2.0)\n fansi              1.0.3    2022-03-24 [1] CRAN (R 4.2.0)\n fastmap            1.1.0    2021-01-25 [1] CRAN (R 4.2.0)\n generics           0.1.3    2022-07-05 [1] CRAN (R 4.2.0)\n GenomeInfoDb       1.34.4   2022-12-01 [1] Bioconductor\n GenomeInfoDbData   1.2.9    2022-12-12 [1] Bioconductor\n glue               1.6.2    2022-02-24 [1] CRAN (R 4.2.0)\n here             * 1.0.1    2020-12-13 [1] CRAN (R 4.2.0)\n highr              0.9      2021-04-16 [1] CRAN (R 4.2.0)\n htmltools          0.5.4    2022-12-07 [1] CRAN (R 4.2.0)\n htmlwidgets        1.5.4    2021-09-08 [1] CRAN (R 4.2.2)\n httr               1.4.4    2022-08-17 [1] CRAN (R 4.2.0)\n IRanges          * 2.32.0   2022-11-01 [1] Bioconductor\n jsonify            1.2.2    2022-11-09 [1] CRAN (R 4.2.0)\n jsonlite         * 1.8.4    2022-12-06 [1] CRAN (R 4.2.0)\n KEGGREST           1.38.0   2022-11-01 [1] Bioconductor\n knitr              1.41     2022-11-18 [1] CRAN (R 4.2.0)\n lifecycle          1.0.3    2022-10-07 [1] CRAN (R 4.2.0)\n magrittr           2.0.3    2022-03-30 [1] CRAN (R 4.2.0)\n memoise            2.0.1    2021-11-26 [1] CRAN (R 4.2.0)\n nodbi            * 0.9.1    2022-11-20 [1] CRAN (R 4.2.0)\n ontologyIndex      2.10     2022-08-24 [1] CRAN (R 4.2.0)\n openssl            2.0.5    2022-12-06 [1] CRAN (R 4.2.0)\n org.Mm.eg.db     * 3.16.0   2022-12-29 [1] Bioconductor\n pillar             1.8.1    2022-08-19 [1] CRAN (R 4.2.0)\n pkgconfig          2.0.3    2019-09-22 [1] CRAN (R 4.2.0)\n plyr               1.8.8    2022-11-11 [1] CRAN (R 4.2.0)\n png                0.1-8    2022-11-29 [1] CRAN (R 4.2.0)\n purrr            * 0.3.5    2022-10-06 [1] CRAN (R 4.2.0)\n R6                 2.5.1    2021-08-19 [1] CRAN (R 4.2.0)\n Rcpp               1.0.9    2022-07-08 [1] CRAN (R 4.2.0)\n RCurl              1.98-1.9 2022-10-03 [1] CRAN (R 4.2.0)\n rlang              1.0.6    2022-09-24 [1] CRAN (R 4.2.0)\n rmarkdown          2.19     2022-12-15 [1] CRAN (R 4.2.0)\n rprojroot          2.0.3    2022-04-02 [1] CRAN (R 4.2.0)\n RSQLite          * 2.2.19   2022-11-24 [1] CRAN (R 4.2.0)\n rstudioapi         0.14     2022-08-22 [1] CRAN (R 4.2.0)\n S4Vectors        * 0.36.1   2022-12-05 [1] Bioconductor\n sessioninfo        1.2.2    2021-12-06 [1] CRAN (R 4.2.0)\n stringi            1.7.8    2022-07-11 [1] CRAN (R 4.2.0)\n stringr            1.5.0    2022-12-02 [1] CRAN (R 4.2.0)\n sys                3.4.1    2022-10-18 [1] CRAN (R 4.2.0)\n tibble           * 3.1.8    2022-07-22 [1] CRAN (R 4.2.0)\n tidyr            * 1.2.1    2022-09-08 [1] CRAN (R 4.2.0)\n tidyselect         1.2.0    2022-10-10 [1] CRAN (R 4.2.0)\n utf8               1.2.2    2021-07-24 [1] CRAN (R 4.2.0)\n uuid               1.1-0    2022-04-19 [1] CRAN (R 4.2.0)\n vctrs              0.5.1    2022-11-16 [1] CRAN (R 4.2.0)\n withr              2.5.0    2022-03-03 [1] CRAN (R 4.2.0)\n xfun               0.35     2022-11-16 [1] CRAN (R 4.2.0)\n XVector            0.38.0   2022-11-01 [1] Bioconductor\n yaml               2.3.6    2022-10-18 [1] CRAN (R 4.2.0)\n zlibbioc           1.44.0   2022-11-01 [1] Bioconductor\n\n [1] /Users/sandmann/Library/R/x86_64/4.2/library\n [2] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}