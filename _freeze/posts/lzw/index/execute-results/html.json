{
  "hash": "11313f9afda6a8f75372e9016ecdd33e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Compressing single-cell RNA-seq data with run-length encoding and LZW\"\nauthor: \"Thomas Sandmann\"\ndate: \"2024-12-23\"\nexecute:\n  echo: true\n  warning: false\n  message: false\nfreeze: true\ncategories: [R, single-cell, RNA-seq, algorithms, TIL]\neditor:\n  markdown:\n    wrap: 72\nformat:\n  html:\n    anchor-sections: true\n    toc: true\n    toc-depth: 4\n    code-tools:\n      source: true\n      toggle: false\n      caption: none\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n## tl;dr\n\n- Today I learned how to compress integer vectors using \n[run-length encoding (RLE)](https://en.wikipedia.org/wiki/Run-length_encoding), \noutput the runs as character vectors, and create a basic implementation\nof the \n[Lempel-Ziv-Welch (LZW)](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\ncompression algorithm.\n- Together, these approaches reduce the amount of information that needs to be\nstored, e.g. in HTML reports, for interactive visualizations.\n- Hat tip to analysis reports generated by \n[Parse Bioscience's analysis pipeline](https://support.parsebiosciences.com/hc/en-us/articles/27066395947412-How-Do-I-Analyze-my-Parse-Biosciences-Data) where I spotted compressed single-cell RNA-seq data for the\nfirst time.\n\n## Motivation\n\nI am always looking for ways to communicate genomics analyses to collaborators\nin a way that allows them to drill down into the data themselves. Stand-alone\nHTML reports can be opened in any web browser and can support rich \nvisualizations, making them my an indespensible tool in my tool kit. \n\nYet, some of the data I am working with, e.g. single-cell RNA-seq data,\nis pretty large, and the size of my HTML reports - which include the data \nas text - can quickly balloon. Luckily, there are ways to compress numerical \ndata without loosing information. \n\nHere, I am exploring two approaches: \n[run-length encoding (RLE)](https://en.wikipedia.org/wiki/Run-length_encoding) and \n[Lempel-Ziv-Welch (LZW) compression](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)[^1].\n\n[^1]: Both of these approaches are used e.g. in the summary HTML reports\ngenerated by Parse Bioscience's analysis pipeline, e.g. in this\n[example report](https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#).\nThe HTML file contains transcriptome-wide gene expression scores for > 50,000\ncells, and users can visualize the expression of their favorite gene on a \nUMAP projection. The whole HTML file is ~ 60 MB in size.\n\n## Sparse information: single-cell RNA-seq data\n\nSingle-cell RNA-seq data are notoriously sparse, e.g. the majority of counts\nacross genes & cells is zero. For example, 96% of all counts in the PBMC 4k\nsingle-cell experiment shared by 10X Genomics (and available via the \n[TENxPBMCData](https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html)\nBioconductor package) are zero:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(TENxPBMCData)\ntenx_pbmc4k <- suppressMessages(TENxPBMCData(dataset = \"pbmc4k\"))\nmean(counts(tenx_pbmc4k) == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9608314\n```\n\n\n:::\n:::\n\n\n\nMost of the remaining counts are integers smaller than ten, with fewer than\n0.2% of values exceeding that range:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(counts(tenx_pbmc4k) > 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.002338497\n```\n\n\n:::\n:::\n\n\n\nThis leads to very long runs of identical integers (most often zero), which\ncan efficiently be represented through \n[run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)\n\nFor example, the expression of the transcription facto _MYC_ gene is highly\nskewed towards zero counts:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyc <- local({\n  ensembl <- row.names(tenx_pbmc4k)[which(rowData(tenx_pbmc4k)$Symbol == \"MYC\")]\n  counts(tenx_pbmc4k)[ensembl, ]\n})\nhist(myc, breaks = 100, xlab = \"MYC (raw counts)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nand there are long sequences of zeros and some shorter sequences of ones in\nthe count vector. (Here, I am only showing counts for the the first 100 of the \n4340 cells.) \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(myc, n = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 0 0 0 1 3 0 0 0 1 0 0 0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\n [38] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 1 0 0 0\n [75] 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0\n```\n\n\n:::\n:::\n\n\n\nR estimates that the entire vector of 4340 counts occupies \n17 KiB of memory.\n\n## Run length encoding\n\nThis information can be communicated more concisely by noting each integer (e.g.\nzero) and the number of times it is repeated. The `stats::rle` function\nperforms this conversion:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_lengths <- rle(myc)\nrun_lengths\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRun Length Encoding\n  lengths: int [1:1195] 3 1 1 3 1 4 3 3 2 14 ...\n  values : int [1:1195] 0 1 3 0 1 0 1 0 1 0 ...\n```\n\n\n:::\n:::\n\n\n\nand returns two components: \n\n1. a vector of values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(run_lengths$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1 3 0 1 0\n```\n\n\n:::\n:::\n\n\n\n2. a vector with the number of times each of them is repeated:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(run_lengths$lengths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 1 3 1 4\n```\n\n\n:::\n:::\n\n\n\nThis allows us to compress the original 4340\nintegers into 2390 integers \n(1195 length & value pairs), \nwithout losing any information.\n\nBy combining information about values and run-lengths, we can reconstruct\nthe original vector, either manually:\n\n```\n0 x 3: 0,0,0,\n1 x 1: 1,\n3 x 1: 3,\n0 x 3: 0,0,0,\n1 x 1: 1,\n0 x 4: 0,0,0,0,\n1 x 3: 1,1,1,\n...\n\n=> 0,0,0,1,3,0,0,0,1,0,0,0,0,1,1,1,...\n```\n\nor via `inverse.rle`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(inverse.rle(run_lengths), n = 16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 1 3 0 0 0 1 0 0 0 0 1 1 1\n```\n\n\n:::\n:::\n\n\n\nTo store run-length encoded values e.g. in a text (or HTML) file, we can also\nrepresent them as characters, similar to our manual reconstruction above, e.g.\nseparating values and lengths with an `x`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyc_rle_separated <- mapply(paste, \n    run_lengths$values, \n    run_lengths$length, \n    MoreArgs = list(sep = \"x\")) |>\n  paste(collapse = \";\")\nsubstr(myc_rle_separated, 1, 40)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x3;1x1;3x1;0x3;1x1;0x4;1x3;0x3;1x2;0x14\"\n```\n\n\n:::\n:::\n\n\n\nThis representation occupies only \n4.9 KiB of memory - but _half_\nof the character string is required to encode the `x` and `;` separators. We\ncan do better!\n\nTo avoid including any separators, we can represent one of the\nnumbers, e.g. the values, as a single character instead. For the _MYC_ gene, the \nlargest observed integer count is 7. So let's represent all \n8 values (including 0) with a letter of the alphabet instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndictionary <- setNames(letters[1:(max(myc) + 1)], 0:max(myc))\ndictionary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  0   1   2   3   4   5   6   7 \n\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \n```\n\n\n:::\n:::\n\n\n\nFor example, the letter `a` represents `0`, `b` represents `1` and so on.\n\nNow we can omit the `x` and `;` separators, as each run is unambiguously\nrepresented by one character and an integer [^2]:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyc_rle_character <- mapply(paste0, \n    dictionary[as.character(run_lengths$values)],  # <1>\n    run_lengths$length) |>\n  paste(collapse = \"\")\nsubstr(myc_rle_character, 1, 21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a3b1d1a3b1a4b3a3b2a14\"\n```\n\n\n:::\n:::\n\n\n\n1. It's critical to coerce the run-length values into a _character_ vector here,\notherwise the named vector is subset by _position_ instead of by _name_.\n\n[^2]: Because runs can be very long, the lengths - represented as integers - \nhave varying number of decimals.\n\nIn this representation, the 4340 counts value for the _MYC_ \ngene now occupy only 2.6 KiB \nof memory instead of the original 17 KiB.\nWe can also write the data to a text (or HTML) file in this format, e.g. as a \nsingle string.\n\n::: {.callout-note}\n\n### Encoding larger numbers of values\n\nIn this example, we only needed 8 letters to encode all observed\nunique counts for the _MYC_ gene. But for other genes, especially those \nexpressed at higher levels, we might observe many more possible values - even\nmore than the 26 lower case letters of the English alphabet.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapdh <- local({\n  ensembl <- row.names(tenx_pbmc4k)[\n    which(rowData(tenx_pbmc4k)$Symbol == \"GAPDH\")]\n  counts(tenx_pbmc4k)[ensembl, ]\n})\n```\n:::\n\n\n\nFor example, in this dataset we observe 59 distinct\ncount values for the highly abundant _GAPDH_ gene:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(gapdh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ngapdh\n  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 \n485 683 708 572 430 302 216 146 118 122  85  56  58  44  40  22  24  25  16  13 \n 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39 \n 18  15  11  10  13   4   6   4  10   4   8   4   4   7   6   1   5   7   2   2 \n 40  41  42  44  46  48  49  50  52  53  54  56  57  61  70  75  85  92 181 \n  5   4   1   4   1   2   1   2   2   1   2   1   1   2   1   1   1   1   1 \n```\n\n\n:::\n:::\n\n\n\nLuckily, we are not restricted to the English alphabet. For example, we can map\nto any character in the \n[Unicode Transformation Format – 8-bit (UTF-8)](https://en.wikipedia.org/wiki/UTF-8)\ncharacter encoding instead.\n\nTo encode e.g. all integers from 1 to 256 (more than enough for _GAPDH_) - but\n*avoiding those that represent a space, quote, etc or integers* - \nwe can use UTF-8 codes 64 to 319:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes <- 64:319\ndictionary <- setNames(intToUtf8(codes, multiple = TRUE), 0:255)\nhead(dictionary, n = 66)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       0        1        2        3        4        5        6        7 \n     \"@\"      \"A\"      \"B\"      \"C\"      \"D\"      \"E\"      \"F\"      \"G\" \n       8        9       10       11       12       13       14       15 \n     \"H\"      \"I\"      \"J\"      \"K\"      \"L\"      \"M\"      \"N\"      \"O\" \n      16       17       18       19       20       21       22       23 \n     \"P\"      \"Q\"      \"R\"      \"S\"      \"T\"      \"U\"      \"V\"      \"W\" \n      24       25       26       27       28       29       30       31 \n     \"X\"      \"Y\"      \"Z\"      \"[\"     \"\\\\\"      \"]\"      \"^\"      \"_\" \n      32       33       34       35       36       37       38       39 \n     \"`\"      \"a\"      \"b\"      \"c\"      \"d\"      \"e\"      \"f\"      \"g\" \n      40       41       42       43       44       45       46       47 \n     \"h\"      \"i\"      \"j\"      \"k\"      \"l\"      \"m\"      \"n\"      \"o\" \n      48       49       50       51       52       53       54       55 \n     \"p\"      \"q\"      \"r\"      \"s\"      \"t\"      \"u\"      \"v\"      \"w\" \n      56       57       58       59       60       61       62       63 \n     \"x\"      \"y\"      \"z\"      \"{\"      \"|\"      \"}\"      \"~\"   \"\\177\" \n      64       65 \n\"\\u0080\" \"\\u0081\" \n```\n\n\n:::\n:::\n\n\n\nAnd then use this dictionary to encode the _GAPDH_ counts:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gapdh, n = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  4  5  1  2  1  2  3 26  2 13  1  5  2  3 24  4  3  3  9  9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngapdh_character <- local({\n  run_lengths <- rle(gapdh)\n  mapply(paste0, \n         dictionary[as.character(run_lengths$values)],\n         run_lengths$length) |>\n    paste0(collapse = \"\")\n})\nsubstr(gapdh_character, 1, 36)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"D1E1A1B1A1B1C1Z1B1M1A1E1B1C1X1D1C2I2\"\n```\n\n\n:::\n:::\n\n\n\nBecause there are more (and shorter) runs in the _GAPDH_ count vector than\nfor _MYC_, the degree of compression we achieve is smaller, from \n17 KiB for the original count vector to \n7.8 KiB for the character\nrepresentation.\n\n:::\n\n::: {.callout-caution collapse=\"true\"}\n\nIn this post, the example dictionaries encode counts up to 256 - but many\nsingle-cell experiments will contain larger integer counts than 256. \n\nFor those, we either need to create a  larger dictionary, or we could opt to\ntruncate larger values (e.g. represent counts >= 256 with the same character,\nlosing information in the process).\n\nWhen visualizing gene expression scores, we often log2 transform the raw or\nnormalized counts, generating floating point numbers. If it is acceptable to\nlose precision, we can round these log2 transformed scores to the nearest\ninteger and apply run-length encoding to them.\n\nBecause 2 to the power of 256 is a very large number (~ 1.16e+77), we would\nbe able to represent even the highest observed scores But on the flip side,\nrounding the log2 transformed scores would obscure some differences between\nexpression levels.\n\n:::\n\n## LZW compression\n\nAt this point, we are representing the original count vectors as character\nstrings. Some of these string representation contain repeated patterns, which\nwe can exploit to compress them even further.\n\n::: {.callout-note collapse=\"true\"}\n\nThe `Lempel–Ziv–Welch` algorithm was the \n[first widely used universal data compression method](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nand is e.g. used in the GIF image format. \n\nAt a high level, the algorithm identifies the longest repeated sequences\n(\"phrases\") in a character string and maps them to shorter expressions in a\ndictionary. \n\n:::\n\nThere are great tutorials about the LZW algorithm and its implementation\navailable on the web, e.g. \n[this one](https://eng.libretexts.org/Bookshelves/Electrical_Engineering/Signal_Processing_and_Modeling/Information_and_Entropy_(Penfield)/03%3A_Compression/3.07%3A_Detail-_LZW_Compression/3.7.01%3A_LZW_Algorithm_Example_1). \nHere, I will create a basic implementation in R [^3]. \n\n[^3]: While this implementation works, it could be improved. For example, it \ndoesn't set any limits on the size of the final dictionary.\n\n### LZW encoding\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompress_lzw <- function(input_string) {\n  dictionary <- setNames(intToUtf8(1:256, multiple = TRUE),   # <1>\n                         intToUtf8(1:256, multiple = TRUE)\n  )\n  next_code <- 257\n  \n  previous_pattern <- character(0)  # <2>\n  output <- character(0)  # <3>\n  \n  for (char in strsplit(input_string, \"\")[[1]]) {  # <4>\n    new_pattern <- paste0(previous_pattern, char)  # <5>\n    if (new_pattern %in% names(dictionary)) {  # <6>\n      previous_pattern <- new_pattern\n    } else {  # <7> \n      output <- paste0(output, dictionary[[previous_pattern]])  # <7>\n      dictionary[[new_pattern]] <- as.character(intToUtf8(next_code))\n      next_code <- next_code + 1\n      previous_pattern <- char\n    }\n  }\n  \n  if (nzchar(previous_pattern)) {\n    output <- paste0(output, dictionary[[previous_pattern]]) # <8>\n  }\n  return(output)\n}\n```\n:::\n\n\n\n1. We initialize a \"dictionary\" (e.g. a named character vector) with 256 UTF-8\ncodes.\n2. As we parse the input string, the current sequence will be stored in the \n`previous_pattern` variable. It is initialized as an empty string.\n3. The `output` variable will collect the compressed output and is \neventually returned. It is also initialized as an empty string.\n4. The input string is split into individual characters, and we process them\none by one.\n5. In the first loop, the `previous_pattern` is still empty. But in subsequent\nloops, we extend the previous one with the new character to identify longer\npatterns.\n6. If the extended pattern is already known, then we don't need to update our\ndictionary. We simply replace the `previous_pattern` with the current one.\n7. If we encounter a _new_ pattern, then we \n  - Encode the `previous_pattern` and add it to the output\n  - Map the new pattern to the next available UTF-8 code\n  - Increment the position of the next available UTF-8 code by one\n  - Reset the previous pattern to the current character.\n8. After the entire string has been processed, we encode the final pattern\nand then return the full output.\n\nLet's apply our LZW compression function to the run-length encoded _MYC_\nexpression we generated above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyc_lzw <- compress_lzw(myc_rle_character)\nmyc_lzw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a3b1d1āăa4b3ć2a1ĊĆ1ĂĒ7ăcĒĈ6Ĉ8Ĉ9Ĉ1ĞėĆ2bĎđa5ĈĪħīĈĖĆ6ąa2ĳ5ĘďĈĥıĦĉĔĴ2ĘĠŁĤĚįĠ0ĮĆ3ĸ1ĸ6ōŃĸĪĒġĒōĿŔĹĒěĆğĎ9ōłĎŚ1ŖĉĺĠĺfĆĨĨŧēĽĝŋœĽĿ20eŭōĻćŴŅĕżŪĒĨ7ąĚĳŰğŋĈ4őĆŚƋāĶĽŰĽƎĆİŨŋŎŕũŭƟĩłŗļıĸƘĩĽŽĖĎŐƥď0Əďŧŝžďĸ3ƇƠĤƵ5ĳěČ8ƸŇĒŉƐŊďƒƒ1ŚĲƀưƈƌſĺƵ7ƣĴƍƃƧƃď4ąĸŽǂǏŧǞƞƌ4aǋhƌĎǢaƵƴĘĳĨ8ƺƩħǠĳǋĿŧĻcĎƝǘĤƲ1ŽƵ2ŚųśȂďǺĚǠǙǅĈŷĜǜŦȕęĒķƐţĴŚƆƐźĴȝŚůƵȇăgǽŪĭƙũƭĠŧĝĎƚƬƛƓȒĆȳȞŃņȜĕňĠœĳǖƻƩȮȿƉȾĴǆȌťɍěȀĳƹȚīǗǋŒļȭȸƶƚȁŌǤĸƚůůȁɣƸǳȱīȢƮĴɅďťĨĬɰĽƾȫɀƻɊƯĂȀƗĞǶĿǼƣǠǠƘȽɛȊɷďȻɯɔƪƂĤĨ3ƅģȷŰǗǕŏǛȹȋȊ3ȪǃșaʞĢ1ȢɠƶűǒƶƒĥĎǼįȐĤǶɣơɤȘʣȱōɍțāŢŧɯŽǤȑȌŽʔȁȁ˂ĺĳĵɆɞǡăŬʾ1ȪȋȅżʛƳȖĠȉƉġĎŽʭȖŧɏʕŽŷ2źơ1ƱǏńžʧʸˬȓȖĨ23˪ſȷƫœƏǗ˟ĉōˈȊ˧ʲƶ˷ōƵʨĔ̉˄ŖʚǣɍŽ̓ƕ˶Ȗŏɪęʯĺɍ3ǎƷǏȊƅʡư˒ĄƄŶ˫ǋɑď˱ŅȰ˺ȔȿȌǀƶ̬˂ʿďɭŚƑơǋŧʨ̬ġʨŚɼaİĸƒʤʢ̤͋ǍƧǶȊ5ǫōźƇȀʨʭƉɯ˃ǇĒʨˡȕČĿɭǌ˄̄ǶʊǵɆ˳ŻŜɋȗŞȢĊɛŷɍˤăƔƠČƵƎɽ̳̱ͦơ̸ĤȢ̔ŭ˂5ͳȖͤ˫ɐʥɇɜȊş˖Ǽ̀Ίͯŋǡͺʩ̲ǩįƿȽĒĥČɷˌǜʉ\\u03a2ɜƨ˸ȃƤȣʫ\\u0378ŋƉ0ȎɕƯ6\"\n```\n\n\n:::\n:::\n\n\n\nAfter LZW compression, R estimates the size of this new character representation\nto be 1.4 KiB, down from \n2.6 KiB after RLE.\n\nNext, let's implement the corresponding decoding function!\n\n### LZW decoding\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndecompress_lzw <- function(compressed) {\n  dictionary <- setNames(intToUtf8(1:256, multiple = TRUE),   # <1>\n                         intToUtf8(1:256, multiple = TRUE)\n  )\n  next_code <- 257\n  \n  compressed_codes <- strsplit(compressed, \"\")[[1]]  # <2>\n  # read the first character and decode it\n  current_code <- compressed_codes[1]  # <3>\n  output <- dictionary[[current_code]] \n  previous_string <- output\n  \n  # read the remaining characters, one by one\n  for (code in compressed_codes[-1]) {  # <4>\n    if (as.character(code) %in% names(dictionary)) {\n      current_string <- dictionary[as.character(code)]  # <5>\n      dictionary[[intToUtf8(next_code)]] <- paste0(previous_string, \n                                                   substr(current_string, 1, 1))\n      \n    } else {\n      current_string <- paste0(previous_string, substr(previous_string, 1, 1))\n      dictionary[[intToUtf8(next_code)]] <- current_string\n      \n    }\n    output <- paste0(output, current_string)  # <6>\n    next_code <- next_code + 1  # <7>\n    previous_string <- current_string  # <8>\n  }\n  return(output)\n}\n```\n:::\n\n\n\n1. The decoding function is provided with the same initial dictionary we\nincluded in the encoding function.\n2. We process the compressed string one character at a time.\n3. The algorithm is initialized with the first character of the encoded string, \nand we decode it using the pre-defined dictionary (which includes all single\ncharacters).\n4. We then iterate over the remaining characters in the compressed input.\n5. We check if the current code is already in our dictionary\n  - If _yes_, then we decode it by looking up its corresponding value in our\n    dictionary. We also add an extended pattern to our dictionary, by\n    concatenating the previous result with the (first character of) our \n    current one.\n  - If _no_, then we decode it by extending the previous result by its (own)\n  first character and add it to the dictionary.\n  character \n6. We add the newly decoded result to our output string.\n7. Increment the running index of our dictionary, because we added a new key.\n8. Get ready for the next iteration.\n\nLet's test the function by restoring the RLE-encoded _MYC_ counts we\ncompressed above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyc_lzw_decompressed <- decompress_lzw(myc_lzw)\nhead(myc_lzw_decompressed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a3b1d1a3b1a4b3a3b2a14b1a13b1a17b1c1a1b1a6b1a8b1a9b1a1b1a9b1c1a2b2a4b1a5b1a5b2a4b1a5b1a7b1a6d1a2d1a5c1a1b1a2b1a6b2a43b1a22c1b1a12c1a2b1a6b1a7b1a10b1a5b1a3c1a1c1a6c1a1b1a12c1a5b1a11b1a1c1a13b1a5b1a1b1a16b1a9b2a9c1a1c1b2a5b1a11b1a4b1a2b1a1b1a2f1a4b1a4b1a1b1a13b2a8b1a3c1a5b2a3b1a20e1a4c1a12b1a3b1a3c1a2b1a17c1a12b1a1b1a14b1a7d1b1a6d1a1b1a19b1a3b1a4c1a1b1a5b1a9b1a3d1a5b2a1b1a1b2a4c1a7b1a4b1a31c1a11b1a2b1a4b1a2b1a5c1b1a1c1a6b1a6c1a4c1a5b2a2b1a7b2a6c1a6b1a10c1a1b1a11b1a6b1a3b1a1c1a3d1b1a4b1a26b1a5d1a6b3a8c1a3b1a7b1a10b1a5b1a5b1a19b1a9b1a15b1a6d1a2b1a10b1a6d1a3b1a3c1b1a26b1a7c1b1a2b1a4b1a1b1c1a4b1a1b1a14d1c1a2b1a8c1a2b1a1b1a4d1a11b1a3b4a9b1a1h1a3b2a8c1a6b1a1b1a6c1d1a4b1a8d1b1a5b2a4c1a2d1a9b1a13b1a1b1a2b1c2a1c1a2b1a2c1a1b1a12b1a6b1a25b1a8b1a1b1a2b1a1d1a9b1a6c1a2b1a4b1a10b1a3b1a2b1a8b1a1b1a11b1a8b1a1b1a15c1a5c1b2a25b1a7d1a5e1a2c1b2a5b1a4b1a16b1a6b1a2b1g1b1a2b1a1b2a4b1a7b1a2b2a6b1a11b1a8b2a7b1a7b2a4b1a3d1a10b1a8b2a25b1a12b1a6b1a5c1a17b1a10b1a1c1a5d1a7c1a4b1a5b1a7b1a5c1d1a1b1a6b1a20b1a2b1a5b1a10b1a6b2a1d1a3d1a15b1a5c1b1a9b1a1b1a12c1a6b2a4b1a3d1a3b1a7b1a1c1a3c1b1a4c1a7b1a4b1a14b1a11c1a7b1a4c1a3d1a4b1a11b1a5e1a6c1a27c1a15b1a14b1a5b2a15b2a5d1b1a2b1a17b1a4b1d1a1b1a6b1a3b2a1b2a4b1a9d1b1a3b1a3b1a1c1b1c1a2c1a24c1b1a12b2a4b1a8b1a1b1a2b1a18b2a7c1a3d1b2a2c1a12b1a24b1a34b1a7b1c1a4b1a1b1a1c1b1a6b1a7c1a6c1a4b1a10b1a1b1a8b1a3g1c1a3b1a1b1a8b1a3b1a9b1e1a3c1a3b1a13b1a3b1a3b1a9b1a2b2a3b1a1b1a7c1a2b1a2d1b1a7b1a4b1a2b1a4b1a14b1a8b1a8b1a11c1a10b1a5c1a3c1a1c1b1a7c1a2b1a1b1a4b1a4b1a2b1a2b1a4b1a7b1c1a1c1a2b1a1b1a2d1a2d1a4b1a7b1a12b1a8b1f1a3c1g1a1b1a12c1a12c1a4b1a11b1a1b1a1b1a15b1a8d1a11b2a2b1a9b1a2b1a1b1a11b1a5b1a10b1c1a2b1a3b1a22e1b1a2b1a10c1a2b1a2c1a3b1e1a3b1a8b1a10b1a3b1a1b1a14b1a23e1b1a3c1a4b1a2b1a7c1a5c1a1b1c1b1a1b2a4c1a11c1a18b1a2b1a3c1a2b1a3b1a23c1a16b1a3c1a3b1c1a16b1a4b1a1b1c1a6c1a2b1a10b1a2b1a2b1a2b2a14b1a2b1a1b1a1c1a6b1a11b1a1b2a3b1a20b1a36d1a1c1a2b1a8b1a4b1a7c1a3b1a10f1a1d1a14b2a3b1a2b1a19b1a16b2a1e1a3b1a2b2a6b1a3c1a3b1a2b1a5c1a2b1a6b3a3b1a6b2a2b1a1c1a1c1a16c1a5b1a5b1a9b1a2b1a9b1a11b1a3c1a6b2a1b3c1a5b1a3b2a7b1c1a9b1a8b1a3b1a1b1a8b1a3b1c1a3b1a5b1a6c1a4d1b1a8b1a5h1c1a1e1d1b2a13c1a9b1a2d1a17c1a1b1a4b1a5b1a13c1a2b1a9b1a8b3a3b1a6c1a15b1a4b1a8b1a2d1b1a1b1a2b1a8d1a4b1a10b1a4c1a16b1a6b1a11b1a9e1a4b2a4b1a3b1a20b1a1b1a5b1d1a5b1a4b3a6b1a4c2a1b1a5c1a15b1a3c1a3b1a2b1a2b1a1c1a2e1a2b1a2b1a42b1a15e1a4b1a1b1a13b1a6b1a2b1a10b1a6b1a9b1a5b1a3d1a8b1a9b2a1b1a13b1a11b2a5e1a16b1a32b1a8d1a5b1a3b1a13b1a2b1a9b1a7d1a6b1a12b1a12b3a1b1a2b1d1a2b1a1b1a8b1a1b1a12b1a3d1a4c1a3e1a2c1a1c1a2c1a3b1a1b1a5b1a3d1a10d1a9b1a15b1a6b1a6\"\n```\n\n\n:::\n:::\n\n\n\nAre the results of sequention compression & decompression really identical\nto the input string?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(\n  decompress_lzw(compress_lzw(myc_rle_character)), \n  myc_rle_character)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n\n#### Compression / decompression example\n\nBecause it's hard to visually compare the long vectors we have compressed & \ndecompressed above, here is a toy example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noriginal_string <- \"MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD\"\ncompressed <- compress_lzw(original_string)\ndecompressed <- decompress_lzw(compressed)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nOriginal String:  MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD \n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCompressed:  MARYHADALITTLELAMBāăąćĉċčďđēĄĆ \n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nDecompressed:  MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD \n```\n\n\n:::\n:::\n\n\n\n:::\n\n## So what?\n\nWe have applied two rounds of compression to our count (or rounded, log2 \ntransformed counts) single-cell RNA-seq data, achieving considerable reduction\nin the size of the objects [^4].\n\n[^4]: Typical file formats used to exchange single-cell RNA-seq count tables\nare using more sophisticated ways of compression. For example, applying\n[gzip compression](https://en.wikipedia.org/wiki/Gzip) to CSV files with\nsparse count data will reduce their sizes tremendously. Other formats, e.g. \n`HDF5` or `Parquet` files also take advantage of compression algorithms.\n\nWhile I have created examples of RLE and LZW compression using R, the same\napproach can be implemented in any programming language. The reports generated\nby Parse Bioscience, for example \n[this one](https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#),\ninclude rounded log2 gene expression counts for all assayed genes across all\ncells that was compressed in the same way [^5]. To decode the compressed \nstrings, the html reports include javascript functions that perform the same\noperations established here.\n\n[^5]: The encoding & compression is happening when the report is generated,\nbut the decoding javascript functions are part of the HTML report.\n\nCombined with interactive plots, users can enter a gene name, triggering the\ndecoding of its gene expression scores and updating a UMP plot in their\nbrowser - without the need for any central server. (Take a look at \n[the source code of one of their reports](https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#)\nto see how this is achieved!)\n\nNow that I have a better understanding of how large amounts of data can be\nincluded in a stand-along HTML document, I am ready to learn more about \njavascript & interactive visualizations [^6]! \n\n[^6]: Greg Wilson's \n[Javascript for Data Scientists](https://third-bit.com/js4ds/)\ncourse has been on my to-do list for a while.\n\n## Reproducibility\n\n<details>\n<summary>\nSession Information\n</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Los_Angeles\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices datasets  utils     methods  \n[8] base     \n\nother attached packages:\n [1] TENxPBMCData_1.24.0         HDF5Array_1.34.0           \n [3] rhdf5_2.50.1                DelayedArray_0.32.0        \n [5] SparseArray_1.6.0           S4Arrays_1.6.0             \n [7] abind_1.4-8                 Matrix_1.7-0               \n [9] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n[11] Biobase_2.66.0              GenomicRanges_1.58.0       \n[13] GenomeInfoDb_1.42.1         IRanges_2.40.1             \n[15] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[17] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n\nloaded via a namespace (and not attached):\n [1] KEGGREST_1.46.0         xfun_0.49               lattice_0.22-6         \n [4] rhdf5filters_1.18.0     vctrs_0.6.5             tools_4.4.1            \n [7] generics_0.1.3          curl_6.0.1              AnnotationDbi_1.68.0   \n[10] tibble_3.2.1            RSQLite_2.3.9           blob_1.2.4             \n[13] pkgconfig_2.0.3         dbplyr_2.5.0            lifecycle_1.0.4        \n[16] GenomeInfoDbData_1.2.13 compiler_4.4.1          Biostrings_2.74.1      \n[19] htmltools_0.5.8.1       yaml_2.3.10             pillar_1.10.0          \n[22] crayon_1.5.3            cachem_1.1.0            mime_0.12              \n[25] ExperimentHub_2.14.0    AnnotationHub_3.14.0    tidyselect_1.2.1       \n[28] digest_0.6.37           purrr_1.0.2             dplyr_1.1.4            \n[31] BiocVersion_3.20.0      fastmap_1.2.0           grid_4.4.1             \n[34] cli_3.6.3               magrittr_2.0.3          withr_3.0.2            \n[37] rappdirs_0.3.3          filelock_1.0.3          UCSC.utils_1.2.0       \n[40] bit64_4.5.2             rmarkdown_2.29          XVector_0.46.0         \n[43] httr_1.4.7              bit_4.5.0.1             png_0.1-8              \n[46] memoise_2.0.1           evaluate_1.0.1          knitr_1.49             \n[49] BiocFileCache_2.14.0    rlang_1.1.4             glue_1.8.0             \n[52] DBI_1.2.3               BiocManager_1.30.25     renv_1.0.11            \n[55] jsonlite_1.8.9          R6_2.5.1                Rhdf5lib_1.28.0        \n[58] zlibbioc_1.52.0        \n```\n\n\n:::\n:::\n\n\n\n</details>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}