{
  "hash": "2a0adf3c494143231117b9a671e5cb5d",
  "result": {
    "markdown": "---\ntitle: \"Simultaneously inserting records into two tables with Postgres CTEs\"\nauthor: \"Thomas Sandmann\"\ndate: \"2023-02-25\"\nfreeze: true\ncategories: [SQL, postgres]\neditor:\n  markdown:\n    wrap: 72\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    code-tools:\n      source: true\n      toggle: false\n      caption: none\neditor_options: \n  chunk_output_type: inline\n---\n\n\n## tl;dr\n\nToday I learned how to \n \n- Use Common Table Expressions (CTEs) to simultaneously insert data into two\n  Postgres tables and\n- Use the `RETURNING` SQL command to retrieve automatically created fields\n  inside the same statement.\n\nGene expression data hosted at the \n[NCBI's Short Read Archive (SRA)](https://www.ncbi.nlm.nih.gov/sra)\nor at the\n[European Nucleotide Archive (ENA)](https://www.ebi.ac.uk/ena/browser/)\nare a great resource. Both repositories represent information for different\nentities that make up a project, e.g. `study`, `sample`, `experiment`, `run`\nand `analysis` information.\n\n![Relationships between entities (source: [ENA](https://ena-docs.readthedocs.io/en/latest/submit/samples.html))](https://ena-docs.readthedocs.io/en/latest/_images/metadata_model_sample.png)\n\nFor example, \n[ENA project PRJNA818657](https://www.ebi.ac.uk/ena/browser/view/PRJNA818657)\nis an RNA-seq study with data for 25 samples. For each sample, a single\nsequencing library (= `experiment`) was prepared and sequenced in _two_\nseparate runs.\n\nIn other words, e.g. \n[sample SAMN26870486](https://www.ebi.ac.uk/ena/browser/view/SAMN26870486)\nproduced \n[experiment SRX14564817](https://www.ebi.ac.uk/ena/browser/view/SRX14564817),\nwhich was then analyzed in\n[run SRR18430942](https://www.ebi.ac.uk/ena/browser/view/SRR18430942) \nand \n[run SRR18430943](https://www.ebi.ac.uk/ena/browser/view/SRR18430943).\n\nOne way to capture this information in a relational database is to set up\nthree tables - one for each entity - and then use ENA's unique sample-,\nexperiment- and run-identifiers as \n[natural primary keys](https://en.wikipedia.org/wiki/Natural_key).\n\nBut what if I don't _have_ suitable natural keys, or simply prefer to use\n[surrogate keys](https://en.wikipedia.org/wiki/Surrogate_key)? \n\nToday, I learned how to \n\n1. `INSERT` a new record into a Postgres database,\n2. automatically generate a primary key,\n3. return the key and\n4. include it in a subsequent `INSERT` statement\n\n### Prerequisites\n\nI am using a Postgres database called `test`, running on the local host and\nconnect to it with the \n[DBI R package](https://dbi.r-dbi.org/), \nvia the \n[RPostgres::Postgres() driver](https://cran.r-project.org/web/packages/RPostgres/index.html).\n\nThen I pass the returned `PqConnection` object to the following SQL code cells\nin this Quarto document.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(RPostgres)\n\ncon <- DBI::dbConnect(\n  RPostgres::Postgres(), \n  dbname = \"test\", \n  host = \"localhost\")\n```\n:::\n\n\n### Creating `experiment` and `run` tables\n\nInitially, the database is empty, so let's create two tables:\n\n- `experiment`: sample-level information\n- `run`: run-level information\n\nEach table will include\n\n1. An auto-generated primary key (`experiment_id` and `run_id`, respectively)\n2. A field to record the record's ENA accession\n3. A time-stamp\n\nand the `run` table will reference its parent `experiment` via the \n`experiment_id` foreign key.\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE IF NOT EXISTS experiment (\n  experiment_id SERIAL PRIMARY KEY,\n  accession text UNIQUE,\n  timestamp timestamp default current_timestamp not null\n)\n```\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nCREATE TABLE IF NOT EXISTS run (\n    run_id SERIAL PRIMARY KEY,\n    accession text UNIQUE,\n    timestamp timestamp default current_timestamp not null,\n    experiment_id integer,\n    FOREIGN KEY(experiment_id) REFERENCES experiment(experiment_id)\n)\n```\n:::\n\n\n### Simultaneously nserting records into both tables\n\nNext, we use a single SQL statement to insert both the experiment _and_ its\nrelated runs:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nWITH\nexp AS (\n  INSERT INTO experiment (accession) \n  VALUES ('SRX14564817') \n  RETURNING experiment_id\n),\ndata(accession) AS (\n  VALUES\n  ('SRR18430942'),\n  ('SRR18430943')\n)\nINSERT INTO run (experiment_id, accession)\nSELECT e.experiment_id, d.accession\nFROM exp e, data d\n```\n:::\n\n\nWe verify that the experiment has been accessioned into the `experiment` table,\nand the same identifier has then be inserted into the `run` table as well\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT e.experiment_id, e.accession AS experiment_accession, \n       r.run_id, r.accession AS run_accession\nFROM experiment e\nINNER JOIN run r ON e.experiment_id = r.experiment_id\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n| experiment_id|experiment_accession | run_id|run_accession |\n|-------------:|:--------------------|------:|:-------------|\n|             1|SRX14564817          |      1|SRR18430942   |\n|             1|SRX14564817          |      2|SRR18430943   |\n\n</div>\n:::\n\n\nLet's examine the individual parts of this query:\n\n- The\n  [WITH](https://www.postgresql.org/docs/current/queries-with.html) \n  command creates a \n  [Common Table Expression (CTE)](https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL#Common_table_expression),\n  e.g. \n  \n  > a temporary named result set, derived from a simple query and defined within\n  the execution scope of a SELECT, INSERT, UPDATE, or DELETE statement.\n  \n  In this example, the `exp` temporary result is generated by the first `INSERT`\n  statement, which updates the `experiment` table. It returns the automatically\n  generated `experiment_id` via the `RETURNING` command. Let's add another\n  accession to the `experiment` table and examine the returned `exp` table:\n  \n\n::: {.cell}\n\n```{.sql .cell-code}\n  WITH\n  exp AS (\n    INSERT INTO experiment (accession) \n    VALUES ('another accession') \n    RETURNING experiment_id\n  )\n  SELECT * FROM exp\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| experiment_id|\n|-------------:|\n|             2|\n\n</div>\n:::\n\n  As expected, the `experiment_id` has been incremented for the next experiment.\n\n- Next, we provide the two run accessions by passing them as `VALUES` to the\n  `data` table.\n  \n\n::: {.cell}\n\n```{.sql .cell-code}\n  WITH\n  data(accession) AS (\n    VALUES\n    ('SRR18430942'),\n    ('SRR18430943')\n  )\n  SELECT * FROM data\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n|accession   |\n|:-----------|\n|SRR18430942 |\n|SRR18430943 |\n\n</div>\n:::\n\n\n- Finally, the second `INSERT` statement adds the two runs to the `run` table,\n  by retrieving the temporary values from both the `exp` and `data` result sets.\n  \nBecause the CTE is a single SQL statement, it runs within a single transaction,\ne.g. it is committed only at the successful completion of the _whole_ statement.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}