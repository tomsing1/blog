{
  "hash": "679dd9ff614307d74fc28ccd381fb2dc",
  "result": {
    "markdown": "---\ntitle: \"Organizing sequencing metadata: experimenting with S7\"\nauthor: \"Thomas Sandmann\"\ndate: \"2023-08-30\"\nfreeze: true\ncategories: [R, TIL]\neditor:\n  markdown:\n    wrap: 72\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    code-tools:\n      source: true\n      toggle: false\n      caption: none\neditor_options: \n  chunk_output_type: console\n---\n\n\n## tl;dr\n\n\nThis week I learned about R's new S7 object oriented programming (OOP) system\nby experimenting with classes that represent the main metadata entities of a\nnext-generation sequencing experiment.\n\n## Introduction\n\nThis week, version 0.1.0 of the\n[S7 R package](https://cran.r-project.org/package=S7)\nwas released on CRAN. Designed by a consortium spanning major R user communities\nit is designed to combine the simplicity of the S3 object oriented programming\nsystem with the control offered by S4. The authors have provided \n[several vignettes](https://rconsortium.github.io/OOP-WG/index.html), \na great starting point for my first steps with S7.\n\n## Next-generation sequencing experiments\n\n[Next generation sequencing](https://en.wikipedia.org/wiki/Massive_parallel_sequencing)\ndata is publicly available from multiple repositories, including\n[The European Nucleotide Archive (ENA)](https://www.ebi.ac.uk/ena/browser/).\nEach dataset contains information about the overall `study`, the analyzed\n`samples`, the sequencing `experiment` (e.g. libraries) and the individual\n`runs` that generated the raw reads [^1].\n\n![ENA metadata model](metadata_model_reads.png)\n\nUnderstanding the relationships between these entities is critical for\ninterpreting and (re-)using the sequencing data. In short:\n\n- One or more runs are part of an experiment.\n- One or more experiments are part of a study.\n- One or more experiments are associated with a sample.\n\n[^1]: [Figure source: ENA documentation](https://ena-docs.readthedocs.io/en/latest/submit/reads/programmatic.html)\n\nLet's represent these entities - and their relationships - as a set of S7\nclasses!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(S7)\nlibrary(checkmate)\n```\n:::\n\n\n## Defining S7 classes\n\nAn S7 class is defined with the `new_class` function, which defines its\nproperties (e.g. corresponding to the _slots_ of an S4 class). \n\nFirst, we define a basic `Entity` class with properties that are shared\nacross all entities in our model. Specifically, we define the `accession` \nand `name` properties, each as a scalar character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEntity <- new_class(\n  \"Entity\",\n  properties = list(\n    accession = class_character,\n    name = class_character\n  )\n)\n```\n:::\n\n\nBy convention, the output of the `new_class` calls is assigned to an object\nwith the same name.\n\n### The Run class\n\nLet's start by defining the `Run` class as a container for metadata about each\nsequencing run. We also specify a validation function to ensure that the\n`read_length` is a positive integers (if it is provided).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRun <- new_class(\n  \"Run\",\n  parent = Entity,\n  properties = list(\n    paired_end = new_property(class_logical, default = FALSE),\n    read_length = class_integer,\n    qc_pass = class_logical\n  ),\n  validator = function(self) {\n    if (length(self@name) == 0) {\n      \"@name must be set\"\n    } else if (length(self@read_length) > 0 && \n               !checkmate::test_count(self@read_length)) {\n      \"@read_length must a positive integer\"\n    }\n  }\n)\n```\n:::\n\n\nCalling the class name (without parentheses) provides basic information about\nits definition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRun\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<S7_class>\n@ name  :  Run\n@ parent: <Entity>\n@ properties:\n $ accession  : <character>\n $ name       : <character>\n $ paired_end : <logical>  \n $ read_length: <integer>  \n $ qc_pass    : <logical>  \n```\n:::\n:::\n\n\nCalling the constructor method (with parentheses) creates a new instance of\nthe class, and the default `print` method lists its properties.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_run <- Run(name = \"first run\", accession = \"r123\", read_length = 100L,\n                 qc_pass = TRUE)\nfirst_run\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Run>\n @ accession  : chr \"r123\"\n @ name       : chr \"first run\"\n @ paired_end : logi FALSE\n @ read_length: int 100\n @ qc_pass    : logi TRUE\n```\n:::\n:::\n\n\nGetter and setter methods are defined automatically and can be accessed with the\n`@` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_run@paired_end <- TRUE\nfirst_run\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Run>\n @ accession  : chr \"r123\"\n @ name       : chr \"first run\"\n @ paired_end : logi TRUE\n @ read_length: int 100\n @ qc_pass    : logi TRUE\n```\n:::\n:::\n\n\nLet's create a second run, this time with paired-end reads:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecond_run <- Run(name = \"second run\", accession = \"r234\", paired_end = TRUE, \n                  qc_pass = FALSE)\nsecond_run\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Run>\n @ accession  : chr \"r234\"\n @ name       : chr \"second run\"\n @ paired_end : logi TRUE\n @ read_length: int(0) \n @ qc_pass    : logi FALSE\n```\n:::\n:::\n\n\n### The Sample class\n\nNext up, a class to hold metadata about each biological sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample <- new_class(\n  \"Sample\",\n  parent = Entity,\n  properties = list(\n    description = class_character,\n    species  = new_property(class_character, default = \"Homo sapiens\"),\n    attributes = class_list,\n    external_ids = class_list\n  )\n)\n```\n:::\n\n\n### The Experiment class\n\nLet's define a container for `Experiment` metadata in a similar way. In \naddition to scalar properties, an `Experiment` also accepts a list of one or\nmore `Run` objects, e.g. the sequencing runs associated with this experiment.\nFinally, we add the `sample` property to represent the biological sample of\norigin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nExperiment <- new_class(\n  \"Experiment\",\n  parent = Entity,\n  properties = list(\n    library_strategy = class_character,\n    library_selection = class_character,\n    library_source = class_character,\n    platform = class_character,\n    model = class_character,\n    runs = class_list,\n    sample = Sample\n  ),\n  validator = function(self) {\n    if (length(self@name) == 0) {\n      \"@name must be set\"\n    } else if (length(self@sample) == 0) {\n      \"@sample is required\"\n    } else if (length(self@sample@name) == 0) {\n      \"@sample@name is required\"\n     } else if (!checkmate::test_list(self@runs, types = \"Run\")) {\n      \"@runs must only contain instances of class `Run`\"\n    }\n  }\n)\n```\n:::\n\n\nThe `runs = class_list` property definition does not specify the types of\nelements the list can contain, so we add a custom validator that requires all\nelements of `runs` to be instances of our previously defined `Run` S7 class.[^2]\n\n::: {.callout-note collapse=\"true\"}\nWe could also have defined an additional calls, e.g. `RunList`, and\ndelegate validating that only `Run` objects are included. That would keep\nthe code more modular, especially if the list of validation rules for the\n`Experiment` class increases. But it would also come at the cost of increasing\nthe number of classes and the complexity of the code base.\n:::\n\n[^2]: I am a big fan of the \n[checkmate R package](https://cran.r-project.org/package=checkmate),\nwhich provides numerous useful functions to assert / check / test objects.\n\nWe instantiate our first experiment and include our two Run objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_sample <- Sample(name = \"first sample\")\nfirst_exp <- Experiment(\n  name = \"first experiment\",\n  accession = \"exp567\",\n  platform = \"Illumina\",\n  model = \"NovaSeq 6000\",\n  runs = list(first_run, second_run),\n  sample = first_sample\n)\nfirst_exp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Experiment>\n @ accession        : chr \"exp567\"\n @ name             : chr \"first experiment\"\n @ library_strategy : chr(0) \n @ library_selection: chr(0) \n @ library_source   : chr(0) \n @ platform         : chr \"Illumina\"\n @ model            : chr \"NovaSeq 6000\"\n @ runs             :List of 2\n .. $ : <Run>\n ..  ..@ accession  : chr \"r123\"\n ..  ..@ name       : chr \"first run\"\n ..  ..@ paired_end : logi TRUE\n ..  ..@ read_length: int 100\n ..  ..@ qc_pass    : logi TRUE\n .. $ : <Run>\n ..  ..@ accession  : chr \"r234\"\n ..  ..@ name       : chr \"second run\"\n ..  ..@ paired_end : logi TRUE\n ..  ..@ read_length: int(0) \n ..  ..@ qc_pass    : logi FALSE\n @ sample           : <Sample>\n .. @ accession   : chr(0) \n .. @ name        : chr \"first sample\"\n .. @ description : chr(0) \n .. @ species     : chr \"Homo sapiens\"\n .. @ attributes  : list()\n .. @ external_ids: list()\n```\n:::\n:::\n\n\n## Custom print methods\n\nAt this point, the output default `print` method for our class becomes a little\nunwieldy, as displaying information about all properties of the `Experiment`,\nits `Sample` and each of the associated `Runs` returns a lot of information.\nLet's define a custom print method for the `Run` class that shows a concise\nsummary instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.run_message <- function(x) {\n  sprintf(\n    \"%s Run%s%s %s\", \n    ifelse(x@paired_end, \"Paired-end\", \"Single-end\"),\n    ifelse(length(x@name) > 0, paste0(\" '\", x@name, \"'\"),\"\"),\n    ifelse(length(x@accession) > 0, paste0(\" (\", x@accession, \")\"), \"\"),\n    ifelse(length(x@qc_pass) == 0, \"❓\", ifelse(x@qc_pass, \"✅\",\"❌\")\n    )\n  )\n}\n\nmethod(print, Run) <- function(x) {\n  cat(.run_message(x))\n}\nfirst_run\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPaired-end Run 'first run' (r123) ✅\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\nDynamically choosing between the three symbols with nested `ifelse` statements\nis confusing - the `dplyr::chase_when()` function offers a nicer interface.\n:::\n\nGreat, that's much shorter. Now we need a `print` method for the `Experiment`\nclass as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.experiment_msg <- function(x) {\n  sprintf(\n    \"Experiment%s%s with %s runs.\", \n    ifelse(length(x@name) > 0, paste0(\" '\", x@name, \"'\"),\"\"),\n    ifelse(length(x@accession) > 0, paste0(\" (\", x@accession, \")\"), \"\"),\n    length(x@runs)\n  )\n}\n\nmethod(print, Experiment) <- function(x) {\n  msg <- .experiment_msg(x)\n  for (run in x@runs) {\n    msg <- paste0(msg, \"\\n- \", .run_message(run))\n  }\n  cat(msg)\n}\n```\n:::\n\n\nNow our first experiment is summarized as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_exp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExperiment 'first experiment' (exp567) with 2 runs.\n- Paired-end Run 'first run' (r123) ✅\n- Paired-end Run 'second run' (r234) ❌\n```\n:::\n:::\n\n\nLet's create a second experiment before we move on:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecond_sample <- Sample(name = \"second sample\")\nsecond_exp <- Experiment(\n  name = \"second experiment\",\n  accession = \"exp628\",\n  platform = \"Illumina\",\n  model = \"NovaSeq 6000\",\n  runs = list(first_run),\n  sample = second_sample\n)\n```\n:::\n\n\n## The Study class\n\nNow that we have defined classes for all of the entities that constitute an\nNGS study, we finish by assembling them into a `Study` class. As before, we also\ndefine a custom `print` method to summarize it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nStudy <- new_class(\n  \"Study\",\n  parent = Entity,\n  properties = list(\n  primary_id = class_character,\n  secondary_id = class_character,\n  description = class_character,\n  abstract = class_character,\n  timestamp = new_property(class_POSIXct, default = as.POSIXct(Sys.time())),\n  experiments = class_list\n  ),\n  validator = function(self) {\n    if (length(self@name) == 0) {\n      \"@name must be set\"\n    } else if (!checkmate::test_list(self@experiments, types = \"Experiment\")) {\n      \"@experiments must only contain instances of class `Experiment`\"\n    }\n  }\n)\n\n.study_msg <- function(x) {\n  sprintf(\n    \"Study%s%s with %s Experiment%s\", \n    ifelse(length(x@name) > 0, paste0(\" '\", x@name, \"'\"),\"\"),\n    ifelse(length(x@accession) > 0, paste0(\" (\", x@accession, \")\"), \"\"),\n    length(x@experiments),\n    ifelse(length(x@experiments) > 1, \"s\", \"\")\n  )\n}\n\nmethod(print, Study) <- function(x) {\n  msg <- .studyt_msg(x)\n  for (experiment in x@experiments) {\n    msg <- paste0(msg, \"\\n- \", .experiment_msg(experiment))\n  }\n  cat(msg)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_study <- Study(name = \"first study\", \n                     experiments = list(first_exp, second_exp))\nfirst_study@experiments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nExperiment 'first experiment' (exp567) with 2 runs.\n- Paired-end Run 'first run' (r123) ✅\n- Paired-end Run 'second run' (r234) ❌\n[[2]]\nExperiment 'second experiment' (exp628) with 1 runs.\n- Paired-end Run 'first run' (r123) ✅\n```\n:::\n:::\n\n\n## Dynamic methods\n\nEach study contains a nested set of `Experiment`, `Sample` and `Run`\nobjects. To access their properties, we redefine the `Study` class by adding\n_computed properties_, e.g. a `runs` property that will return a list of\n`Runs` from all experiments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nStudy <- new_class(\n  \"Study\",\n  parent = Entity,\n  properties = list(\n  primary_id = class_character,\n  secondary_id = class_character,\n  description = class_character,\n  abstract = class_character,\n  timestamp = new_property(class_POSIXct, default = as.POSIXct(Sys.time())),\n  experiments = class_list,\n  runs = new_property(\n    getter = function(self) {\n      exp_runs <- setNames(\n        lapply(self@experiments, \\(x) x@runs),\n        vapply(self@experiments, \\(x) x@name, FUN.VALUE = character(1)))\n    }\n  )\n  ),\n  validator = function(self) {\n    if (length(self@name) == 0) {\n      \"@name must be set\"\n    } else if (!checkmate::test_list(self@experiments, types = \"Experiment\")) {\n      \"@experiments must only contain instances of class `Experiment`\"\n    }\n  }\n)\n```\n:::\n\n\nNow, the study's `@runs` property returns a nested list with one element for\neach experiment (and all runs for each experiment).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecond_study <- Study(name = \"first study\", \n                     experiments = list(first_exp, second_exp))\nexp_runs <- second_study@runs\nstr(exp_runs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ first experiment :List of 2\n  ..$ : <Run>\n  .. ..@ accession  : chr \"r123\"\n  .. ..@ name       : chr \"first run\"\n  .. ..@ paired_end : logi TRUE\n  .. ..@ read_length: int 100\n  .. ..@ qc_pass    : logi TRUE\n  ..$ : <Run>\n  .. ..@ accession  : chr \"r234\"\n  .. ..@ name       : chr \"second run\"\n  .. ..@ paired_end : logi TRUE\n  .. ..@ read_length: int(0) \n  .. ..@ qc_pass    : logi FALSE\n $ second experiment:List of 1\n  ..$ : <Run>\n  .. ..@ accession  : chr \"r123\"\n  .. ..@ name       : chr \"first run\"\n  .. ..@ paired_end : logi TRUE\n  .. ..@ read_length: int 100\n  .. ..@ qc_pass    : logi TRUE\n```\n:::\n:::\n\n\n## Conclusions\n\nAfter working with the S4 OOP for a while, the new S7 package was a pleasant\nsurprise. There was less boilerplate code to write, and the definition of\nclasses and methods seems straightforward. I noticed a few issues, which had\nalso been noted by other R users:\n\n- As pointed out by Kevin Kunzmann\n  [in this github issue](https://github.com/RConsortium/OOP-WG/issues/275)\n  the ability to define additional constraints for properties within e.g. \n  `class_character` would be a welcome addition. I found myself writing custom\n  validators to check whether a property had been set\n  (e.g. `length(x@name) > 0`).\n- The `Entity` class defines the `@name` and `@accession` properties, along\n  with a validator for the former. Unfortunately, that validator is \n  not inherited by the child classes, as noted by Jamie Lendrum\n  [in this github issue](https://github.com/RConsortium/OOP-WG/issues/329),\n  so I had to repeat the same code in each class definition.\n    \n## Reproducibility\n\n<details>\n<summary>\nSession Information\n</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info(\"attached\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Ventura 13.5.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Los_Angeles\n date     2023-08-30\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package   * version date (UTC) lib source\n P checkmate * 2.2.0   2023-04-27 [?] CRAN (R 4.3.0)\n P S7        * 0.1.0   2023-08-24 [?] CRAN (R 4.3.0)\n\n [1] /Users/sandmann/repositories/blog/renv/library/R-4.3/aarch64-apple-darwin20\n [2] /Users/sandmann/Library/Caches/org.R-project.R/R/renv/sandbox/R-4.3/aarch64-apple-darwin20/ac5c2659\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>\n   ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}