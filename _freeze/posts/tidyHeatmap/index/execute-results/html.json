{
  "hash": "f04156212b4f94cba6c20caa4120ee59",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exploring the tidyHeatmap R package\"\nsubtitle: \"Reproducing heatmaps published in Xia et al, Molecular neurodegeneration, 2022\"\nauthor: \"Thomas Sandmann\"\ndate: \"2024-10-12\"\nfreeze: true\ncategories: [R, TIL]\neditor:\n  markdown:\n    wrap: 72\nformat:\n  html:\n    toc: true\n    toc-depth: 4\n    code-tools:\n      source: true\n      toggle: false\n      caption: none\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## tl;dr\n\nThis week I learned about the `tidyHeatmap` package, which wraps the\nfunctionality of the awesome \n[ComplexHeatmap R package](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html)\ninto functions with a tidyverse interface. No more need for pivoting tidy \ndatasets into matrices and back!\n\n\n\n\n\n\n\n## Installing the tidyHeatmap R package\n\nThe `tidyHeatmap` R package is available from\n[CRAN](https://cran.r-project.org/package=tidyHeatmap) [^1].\n\n[^1]: Because `tidyHeatmap` relies heavily on other packages from the\n[tidyverse](https://www.tidyverse.org/),\ne.g. the \n[dplyr](https://dplyr.tidyverse.org//)\nand \n[tidyr](https://tidyr.tidyverse.org//)\nR packages, it has a relatively deep dependency tree. But that's \npar for the course if you want to adopt the \n[tidy tools API](https://tidyverse.tidyverse.org/articles/manifesto.html) \nby using Posit's toolchain.\n\nThe latest release available from CRAN can be installed via: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyHeatmap\")\n```\n:::\n\n\n\nand the latest development version (used in this tutorial) is available\nfrom github:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"stemangiola/tidyHeatmap\")\n```\n:::\n\n\n\n::: { .callout-note }\n At the time of writing, the latest version available from CRAN (version \n1.8.1) is outdated; please install & use the latest development version from\ngithub (currently version 1.10.2) to follow along with this tutorial.\n\n:::\n\nIn addition, we will use the following R packages, all of which can be installed\nfrom CRAN with `install.packages()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(circlize)  # to create continuous color gradients\nlibrary(dplyr)  # wrangling tidy tables\nlibrary(grid)  # to define witdth / height of annotations using grid::unit()\nlibrary(ragg)  # to generate high quality graphics\nlibrary(RColorBrewer)  # to access predefined color palettes\nlibrary(tibble)  # to convert data.frames to tibbles\nlibrary(tidyHeatmap) # the main act: plotting & annotating heatmaps\n```\n:::\n\n\n\n## Targeted lipidomics data published by Xia et al\n\nIn this tutorial we will used targeted mass spectrometry data \npublished by \n[Xia et al, Molecular neurodegeneration, 2022](https://molecularneurodegeneration.biomedcentral.com/articles/10.1186/s13024-022-00547-7)\nand reproduce \nFigures 5a and 5b[^2]:\n\n![Figure 5 from Xia et al, 2022](https://media.springernature.com/full/springer-static/image/art%3A10.1186%2Fs13024-022-00547-7/MediaObjects/13024_2022_547_Fig5_HTML.png?as=webp)\n\n[^2]: Well approximately: \n[In the publication](https://molecularneurodegeneration.biomedcentral.com/articles/10.1186/s13024-022-00547-7/figures/5) the authors estimated and\nsubtracted effects due to `batch`, `sex` and two\n[surrogate variables](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1994707/)\nwith a linear model, and then plotted the \n[residuals](https://en.wikipedia.org/wiki/Errors_and_residuals)\nfor each data point. This adjustment was motivated by the\nexperimental design and the statistical analysis, which also incorporated\nthese covariates to determine whether differences between the experimental\ngroups were statistically significant. Here, we will plot the normalized\nabundances for each analyte directly, without any adjustment. Nevertheless,\nthe heatmap will look quite similar (albeit not quite as _smooth_ as the \noriginal).\n\n## Available datasets\n\n- Normalized abundances: [Supplementary table 8](https://static-content.springer.com/esm/art%3A10.1186%2Fs13024-022-00547-7/MediaObjects/13024_2022_547_MOESM15_ESM.xlsx)\nis an excel file containing the normalized abundances for\n225 analytes measured across 30 samples.\n  - The `get_abundances()` function defined in the callout box below starts by\n  downloading the supplementary excel file, and then wrangles sample\n  annotations, feature annotations and the measurements into a tidy tibble.\n  - Alternatively, you can download a CSV file with the pre-wrangled dataset\n  [here](https://raw.githubusercontent.com/tomsing1/blog/refs/heads/main/posts/tidyHeatmap/abundances.csv).\n\n::: {.callout-tip  collapse=\"true\"}\n\n#### The get_abundances() function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(checkmate)  # helper function for (optional) helper functions\nlibrary(readxl)  # reading excel files\nlibrary(tidyr)  # pivoting from wide to long tables (and more!)\n\n#' @noRd\n#' @param path Scalar character, the path to the supplementary excel file\n#' @importFrom checkmate assert_file\n#' @importFrom readxl read_excel\n.parse_sample_annotations <- function(path) {\n  checkmate::assert_file(path)\n  # parse sample- and feature-annotations, and normalized abundances\n  df <- readxl::read_excel(path, sheet = \"sample_annotations\")\n  df$sample_id <- vapply(\n    strsplit(df$sample_id, \"_\"), \\(x) x[[2]], FUN.VALUE = character(1)\n  )\n  df[, c(\"sample_id\",  \"description\", \"cell_number\", \"genotype\", \"condition\",\n         \"sex\", \"batch\")]\n}\n\n#' @noRd\n#' @param path Scalar character, the path to the supplementary excel file\n#' @importFrom checkmate assert_file\n#' @importFrom readxl read_excel\n.parse_feature_annotations <- function(path) {\n  checkmate::assert_file(path)\n  df <- readxl::read_excel(path, sheet = \"feature_annotations\")\n  df <- df[, grep(\"QTRAP|XEVO|m.z\", colnames(df), invert = TRUE)]\n  df <- df[!duplicated(df$component_name), ]\n  df$feature_id <- NULL\n  df <- df[!df$is_internal_standard,]\n  df[, setdiff(\n    colnames(df), c(\"is_internal_standard\")),\n    drop = FALSE]\n}\n\n#' @noRd\n#' @param path Scalar character, the path to the supplementary excel file\n#' @importFrom checkmate assert_file\n#' @importFrom tidyr pivot_longer\n#' @importFrom readxl read_excel\n.parse_abundances <- function(path) {\n  checkmate::assert_file(path)\n  df <- readxl::read_excel(path, sheet = \"peak_area_ratio_to_is\")\n  df <- data.frame(\n    component_name = df$component_name,\n    df[, grep(\"^NE\", colnames(df), value = TRUE)]\n  )\n  df <- tidyr::pivot_longer(df, cols = setdiff(colnames(df), \"component_name\"),\n                            names_to = \"sample_id\", values_to = \"abundance\")\n  df$sample_id <- vapply(\n    strsplit(df$sample_id, \"_\"), \\(x) x[[2]], FUN.VALUE = character(1)\n  )\n  return(df)\n}\n\n#' Retrieve targeted LC/MS data published by Xia et al, 2022 as Suppl. Table 7\n#' @importFrom dplyr left_join join_by\n#' @export\n#' @return A tidy tibble with 2,718 rows and 9 columns\n#' @source [Xia et al, Molecular neurodegeneration, 2022](https://molecularneurodegeneration.biomedcentral.com/articles/10.1186/s13024-022-00547-7)\n#' @examples\n#' get_abundances()\nget_abundances <- function() {\n  url <- paste0(\n    \"https://static-content.springer.com/esm/art%3A10.1186%2Fs13024-022-00547-7/\",\n    \"MediaObjects/13024_2022_547_MOESM15_ESM.xlsx\")\n  \n  # retrieve the first supplementary data file\n  tmp_file <- tempfile(fileext = \".xlsx\")\n  download.file(url, tmp_file, quiet = TRUE)\n  # parse sample- and feature-annotations & normalized abundances\n  sample_anno <- .parse_sample_annotations(tmp_file)\n  feature_anno <- .parse_feature_annotations(tmp_file)\n  abundances <- .parse_abundances(tmp_file)\n  # join all tables into a single tidy tibble\n  dplyr::left_join(\n    feature_anno, abundances, by = dplyr::join_by(\"component_name\")) |>\n    dplyr::left_join(sample_anno, by = dplyr::join_by(\"sample_id\")) |>\n    dplyr::mutate(\n      sample_id = factor(sample_id, levels = as.character(seq.int(30))),\n      sex = factor(sex),\n      condition = factor(condition),\n      ionization = factor(ionization),\n      batch = factor(batch),\n      genotype = factor(genotype, levels = c(\"WT\", \"APP_SAA_Hom\")),\n      group = factor(paste(genotype, condition, sep = \", \"),\n                     levels = c(\"WT, Methoxy_Neg\", \"APP_SAA_Hom, Methoxy_Neg\",\n                                \"APP_SAA_Hom, Methoxy_Pos\")),\n      group = dplyr::recode_factor(\n        group, \n        \"WT, Methoxy_Neg\" = \"WT, Methoxy-\", \n        \"APP_SAA_Hom, Methoxy_Neg\" = \"APP-SAA, Methoxy-\",\n        \"APP_SAA_Hom, Methoxy_Pos\" = \"APP-SAA, Methoxy+\"\n      )\n    )\n}\n```\n:::\n\n\n\n:::\n\n- Differential abundance analysis: [Supplementary table 8](https://static-content.springer.com/esm/art%3A10.1186%2Fs13024-022-00547-7/MediaObjects/13024_2022_547_MOESM16_ESM.xlsx)\nis an excel file with the results of the differential abundance analysis\n(performed by fitting a linear model for each analyte with the \n[limma Bioconductor package](https://bioconductor.org/packages/release/bioc/html/limma.html)\n), e.g. it provides log2 fold changes, p-values, and adjusted p-values (FDR)\nfor multiple comparisons of interest. \n  - The `get_stats()` function, shown in the\n  callout box below, retrieves and parses this file for us and returns a \n  tidy tibble.\n  - Alternatively, you can download the pre-wrangled statistics in a CSV file\n  [here](https://raw.githubusercontent.com/tomsing1/blog/refs/heads/main/posts/tidyHeatmap/statistics.csv).\n\n::: {.callout-tip  collapse=\"true\"}\n\n#### The get_stats() function\n\n\n#| message: false\n\nlibrary(readxl)  # reading excel files\n\n#' Retrieve and parse differential abundance statistics from Suppl. Table 8\n#' @noRd\n#' @examples\n#' get_stats()\nget_stats <- function() {\n  url <- paste0(\n    \"https://static-content.springer.com/esm/art%3A10.1186%2Fs13024\",\n    \"-022-00547-7/MediaObjects/13024_2022_547_MOESM16_ESM.xlsx\"\n  )\n  tmp_file <- tempfile(fileext = \".xlsx\")\n  download.file(url, tmp_file, quiet = TRUE)\n  readxl::read_excel(tmp_file, sheet = \"3. APP_pos_vs_WT_neg\") |>\n    dplyr::rename(component_name = \"symbol\")\n}\n```\n:::\n\nFirst, we download and read the two CSV files with the pre-wrangled abundance\nand statistics data. For compatibility with the `tidyHeatmap` package,\nwe convert both tables into tibbles as well:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\n  'https://raw.githubusercontent.com/tomsing1/tidy_heatmap/main/abundances.csv',\n  stringsAsFactors=TRUE) |>\n  tibble::as_tibble()\nstats <- read.csv(\n  'https://raw.githubusercontent.com/tomsing1/tidy_heatmap/main/statistics.csv',\n  stringsAsFactors=TRUE) |>\n  tibble::as_tibble()\nstopifnot(all(stats$component_name %in% df$component_name))\n```\n:::\n\nXia et al only included analytes with a log2 fold change > 20% and an adjusted\np-values < 0.1 in Figure 5. Let's identify the names of the significant analytes\nin our `stats` data.frame by applying these thresholds. Then we order the\nanalytes by their log2 fold change and pull out the `component_name` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsignificant <- stats |>\n  dplyr::filter(abs(stats$logFC) > 0.2, adj.P.Val < 0.1) |>\n  dplyr::arrange(desc(logFC)) |>\n  dplyr::pull(component_name)\nhead(significant)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] GM3(d36:1)    TG(20:4_36:3) Spermine      TG(20:4_32:1) PS(16:0_20:4)\n[6] TG(20:4_34:2)\n225 Levels: (3-O-sulfo)GalCer(d18:1/16:0) ... Xanthine\n```\n\n\n:::\n:::\n\n\nWe retain 117 significant analytes, e.g. `GM3(d36:1)`,\n`TG(20:4_36:3)` and `Spermine` are most strongly increased in\nAPP-SAA, methoxy+ compared to WT, methoxy- samples.\n\nNext, we subset the abundance table (`df`) to only retain these significant\nanalytes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df |>\n  dplyr::filter(component_name %in% significant)\n```\n:::\n\n\nNow we have the data in a tidy tibble with 3510 rows and 13\ncolumns.\n\nTo control the order of categorical variables (e.g. `genotype` or or `batch`),\nthey are encoded as factors.[^3]. To match the order of the groups in Figure 5,\nwe `recode` the levels of the `group` variable, so the `WT, Methoxy-` group\nis listed first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$group = dplyr::recode_factor(\n    df$group, \n    \"WT, Methoxy_Neg\" = \"WT, Methoxy-\", \n    \"APP_SAA_Hom, Methoxy_Neg\" = \"APP-SAA, Methoxy-\",\n    \"APP_SAA_Hom, Methoxy_Pos\" = \"APP-SAA, Methoxy+\"\n)\n```\n:::\n\n\n[^3]: For example, the two possible values of `genotype` are: `WT` and\n`APP_SAA_Hom`, and the three levels of the `group` variable are\n`WT, Methoxy-`, `APP-SAA, Methoxy-` and `APP-SAA, Methoxy+`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                       component_name    ionization  \n (3-O-sulfo)GalCer(d18:1/24:1):  30   negative:1170  \n Acetylcarnitine              :  30   positive:2340  \n Adenine                      :  30                  \n Adenosine diphosphate ribose :  30                  \n alpha-Tocopherol             :  30                  \n Arginine                     :  30                  \n (Other)                      :3330                  \n                    assigned_internal_standard        panel        sample_id   \n PC(15:0/18:1(d7))-Lipid-pos     : 330         Lipid     :2610   Min.   : 1.0  \n TG(15:0/18:1(d7)/15:0)-Lipid-pos: 300         Metabolite: 900   1st Qu.: 8.0  \n PE(15:0/18:1(d7))-Lipid-neg     : 240                           Median :15.5  \n PE(15:0/18:1(d7))-Lipid-pos     : 210                           Mean   :15.5  \n Arginine-d4C13-Metabolite-pos   : 150                           3rd Qu.:23.0  \n GlcCer(d18:1(d5)/18:0)-Lipid-pos: 150                           Max.   :30.0  \n (Other)                         :2130                                         \n   abundance                  description    cell_number           genotype   \n Min.   :-12.6100   HOM, Methoxy NEG:1170   Min.   :19022   APP_SAA_Hom:2340  \n 1st Qu.: -5.2800   HOM, Methoxy POS:1170   1st Qu.:47311   WT         :1170  \n Median : -2.1395   WT, Methoxy NEG :1170   Median :50000                     \n Mean   : -2.1045                           Mean   :45504                     \n 3rd Qu.:  0.7407                           3rd Qu.:50000                     \n Max.   : 13.2500                           Max.   :50000                     \n NA's   :38                                                                   \n       condition        sex         batch                    group     \n Methoxy_Neg:2340   Female:1287   Day_1: 702   WT, Methoxy-     :1170  \n Methoxy_Pos:1170   Male  :2223   Day_2:1404   APP-SAA, Methoxy-:1170  \n                                  Day_3:1404   APP-SAA, Methoxy+:1170  \n                                                                       \n                                                                       \n                                                                       \n                                                                       \n```\n\n\n:::\n:::\n\n\nWe are ready to plot our first heatmap!\n\n## A first heatmap\n\nThe `tidyHeatmap` R package provides wrapper functions that make the\nfunctionality of the\n[ComplexHeatmap Bioconductor package](https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html)\navailable within a tidy workflow. [^4]\n\n[^4]: The documentation of the `ComplexHeatmap` package is amazing: the\n[Complete Reference](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html) contains to 15 chapters.\n\nCreating a first heatmap is as easy as passing our tidy tibble into the \n`tidyHeatmap::heatmap()` function, and specifying which columns contain\nrow identifiers, column identifiers and values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(.data = df, .row = component_name, .column = sample_id, \n        .value = abundance, scale = \"row\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=720}\n:::\n:::\n\n\n::: {.callout-tip  collapse=\"false\"}\n\nThe normalized abundances are hard to interpret (because analytes were\nnormalized to different internal standards and don't correspond to absolute\nconcentrations). Luckily, we are mainly interested in more interested in the\nrelative changes across samples (and groups of samples). By setting \n`scale = \"row\"`, the values for each analyte are converted to z-scores - and\nthe color scale indicates variation around the mean of each row.\n\n:::\n\nWe can pass additional arguments through to the `ComplexHeatmap::Heatmap()`\nfunction, e.g. specify another method to cluster rows via the \n`clustering_method_rows` argument, by suppressing column clustering entirely\nvia `cluster_columns=FALSE`, or by defining the color palette to use [^5].\n\n[^5]: See \n[Heatmap's help page](https://www.rdocumentation.org/packages/ComplexHeatmap/versions/1.10.2/topics/Heatmap) \nfor a full list of arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors <- circlize::colorRamp2(\n  breaks = c(-2, 0, 2),\n  # seq(2, -2, length.out = 11), \n  colors = c(\"navy\", \"white\", \"firebrick\")\n  # RColorBrewer::brewer.pal(11, \"RdBu\")\n)\nheatmap(.data = df,\n        .row = component_name, \n        .column = sample_id, \n        .value = abundance, \n        column_title = \"Xia et al: targeted LC/MS data\",\n        row_title = \"Analyte\",\n        scale = \"row\",\n        cluster_columns = FALSE,\n        clustering_method_rows = \"ward.D\",\n        palette_value = colors\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=720}\n:::\n:::\n\nWe can also introduce visual splits between the columns, e.g. separating\nthe three genotypes from each other, and assign a different color to each one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(group) |>\n  heatmap(.row = component_name, \n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          scale = \"row\",\n          cluster_columns = FALSE,\n          clustering_method_rows = \"ward.D\",\n          clustering_method_columns = \"ward.D\",\n          palette_value = colors,\n          palette_grouping = list(\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n        )\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=720}\n:::\n:::\n\n\n::: {.callout-tip  collapse=\"true\"}\n\n## Splitting features\n\nThe dendrogram (on the left) indicates that there might be two major groups\nof features in this dataset, e.g. there are two main branches. \n\n### Cutting the hierarchical clustering result\n\nWe can reinforce this result by cutting the dendrogram after two branches have\narisen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(group) |>\n  heatmap(.row = component_name, \n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          scale = \"row\",\n          cluster_columns = FALSE,\n          clustering_method_rows = \"ward.D\",\n          clustering_method_columns = \"ward.D\",\n          palette_value = colors,\n          palette_grouping = list(\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n        )\n  ) |>\n    split_rows(2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=720}\n:::\n:::\n\n\n### K-means clustering\n\nAlternatively, we can can perform\n[k-means clustering](https://en.wikipedia.org/wiki/K-means_clustering)\non the rows (or columns) by specifying the number of clusters (k) to isolate\nvia the `row_km` argument. Our current dataset contains missing values \n(`NA`), which is incompatible with the k-means clustering algorithm. To use this\nmethod we first need to decide how to handle missing values, e.g. drop analytes\nor impute reasonable values.\n\n:::\n\n## Adding annotations\n\nThe `annotation_tile()` function[^6] allows us to add additional annotations to\nour heatmap, e.g. to identify \n\n- columns from the `batches` or correspoding to animals with male or female \n  `sex` in an annotation bar on top of the heatmap, or\n- rows with values from different `panels` (lipds, metabolits) in an annotation\n  strip on the left of the heatmap.\n\n[^6]: Prior to `tidyHeatmap` version 1.9.0, the `add_tile()` function was used\ninstead. It is now deprecated in favor of `annotation_tile()`. (At the time of\nwriting, the latest version available from CRAN is version 1.8.1; please\ninstall & use the latest development version from github to follow along this\ntutorial.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(group) |>\n  heatmap(.row = component_name, \n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          scale = \"row\",\n          cluster_columns = FALSE,\n          clustering_method_rows = \"ward.D\",\n          clustering_method_columns = \"ward.D\",\n          palette_value = colors,\n          palette_grouping = list(\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n        )\n  ) |>\n    annotation_tile(\n        batch, \n        palette = RColorBrewer::brewer.pal(3, \"Dark2\")\n    ) |>\n    annotation_tile(sex, \n             palette = c(\"skyblue\", \"pink\")) |>\n    annotation_tile(panel, size = grid::unit(5, \"points\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=720}\n:::\n:::\n\n\n::: {.callout-tip  collapse=\"true\"}\n\n### Row or column annotations?\n\nThe `annotation_tile()` function does not require us to specify whether we\nare adding row or column annotations. Instead, it infers it automatically:\n\n- Does each value used to define a row of the heatmap (e.g. `component_name`)\n  map to a single value in the selected column of the data.frame?\n  - If yes, create a row annotation strip.\n- Does each value used to define a column of the heatmap (e.g. `sample_id`)\n  map to a single value in the selected column of the data.frame?\n  - If yes, create a column annotation.\n- If neither of the above are true, an error is raised.\n\n:::\n\n## Adding quantitative annotations\n\nSome annotations are quantitative, and may be better communicated in a plot.\nLet's display the number of cells that were analyzed in each sample on top of\nour heatmap with the `add_point()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(group) |>\n  heatmap(.row = component_name, \n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          scale = \"row\",\n          cluster_columns = FALSE,\n          clustering_method_rows = \"ward.D\",\n          clustering_method_columns = \"ward.D\",\n          palette_value = colors,\n          palette_grouping = list(\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n          )\n  ) |>\n  annotation_tile(\n    batch, \n    palette = RColorBrewer::brewer.pal(3, \"Dark2\")\n  ) |>\n  annotation_tile(\n    sex, \n    palette = c(\"skyblue\", \"pink\")\n  ) |>\n  annotation_tile(panel, size = grid::unit(5, \"points\")) |>\n  annotation_point(cell_number)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=720}\n:::\n:::\n\n\n::: {.callout-tip  collapse=\"true\"}\n\n## Overlaying symbols\n\nTo highlight specific cells in our heatmap, the `layer_point()`, \n`layer_arrow_up()`, `layer_arrow_down()`, `layer_diamond()`, `layer_square()`,\n`layer_star()`, `layer_text()` or `layer_asterisk()`\nfunctions can be used, together with a filter condition [^7].\n\n[^7]: At the time of writing, the latest version of the `tidyHeatmap` package\navailable from CRAN is version 1.8.1. The development version used here, \navailable [from github](https://github.com/stemangiola/tidyHeatmap),\ncontains additional functionality, including e.g. the `layer_star()` and - most\nimportantly - `layer_asterisk()`.\n\nCan you spot the asterisks for `GM3(d36:1)` for samples 1, 3, and 6 in the \nheatmap below?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  group_by(group) |>\n  heatmap(.row = component_name, \n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          scale = \"row\",\n          cluster_columns = FALSE,\n          clustering_method_rows = \"ward.D\",\n          clustering_method_columns = \"ward.D\",\n          palette_value = colors,\n          palette_grouping = list(\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n        )\n  ) |>\n  annotation_tile(\n    batch, \n    palette = RColorBrewer::brewer.pal(3, \"Dark2\")\n  ) |>\n  annotation_tile(sex, \n                  palette = c(\"skyblue\", \"pink\"))  |>\n  annotation_tile(panel, size = grid::unit(5, \"points\")) |>\n  layer_asterisk(\n    component_name == \"GM3(d36:1)\" & sample_id %in% c(\"1\", \"3\", \"6\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=720}\n:::\n:::\n\n\n:::\n\n## Manually ordering rows\n\nFor Figure 5, Xia et al manually ordered the rows, with those analytes showing\nthe largest log2 fold increases at the top, and those with the largest decreases\n(e.g. negative log2 fold changes) at the bottom. \n\nTo reproduce this, we switch off the clustering of the rows, and change the\norder of the `component_name` factor to the `significant` character vector - \nwhich is ordered from largest to smallest fold change (see above) - with the\n`dplyr::mutate()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  dplyr::mutate(\n    component_name = factor(component_name, levels = significant)\n  ) |>\n  group_by(group, panel) |>\n  heatmap(.row = component_name, \n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          scale = \"row\",\n          cluster_columns = FALSE,\n          cluster_rows = FALSE,\n          palette_value = colors,\n          palette_grouping = list(\n            palette.colors(2, \"Set1\"),\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n        )\n  ) |>\n  annotation_tile(\n    batch, \n    palette = RColorBrewer::brewer.pal(3, \"Dark2\"),\n    size = grid::unit(10, \"points\")\n  ) |>\n  annotation_tile(\n    sex, \n    palette = c(\"skyblue\", \"pink\"),\n    size = grid::unit(10, \"points\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=720}\n:::\n:::\n\n\nIn this step, we also changed the `group_by` command: we grouped by both\nthe `group` and the `panel` annotations, splitting columns and rows of our\nheatmap into separate panels, respectively.\n\n## Manually scaling rows\n\nSo far, we have scaled each row by converting the measurements for each\nanalyte to \n[z-scores](https://en.wikipedia.org/wiki/Standard_score),\nand the colors reflect differences from the overall mean across all samples.\n\nIn many experiments, including this one, there is an explicit experimental \ngroup that provides a natural baseline. The effects of the `APP-SAA` genotype\nis usually interpret relative to the `WT` control group. We therefore center\nthe abundances by subtracting the median value observed in this \n(e.g. the `WT, methoxy-`) group. Now the colors indicate log2 fold changes\nrelative to the median in the control group.\n\n::: {.callout-tip  collapse=\"false\"}\n\nHere, we use functions from the `dplyr` package to \n\n1. `group_by`: group the tibble by `component_name`, so we can perform\n  calculations separately for each analyte,\n2. `mutate`: calculate the median for the abundances observed in the\n   `WT, Methoxy-` group (for this analyte)\n3. `mutate`: subtract the control median from each value (for this analyte).\n4. `ungroup`: ungroup the tibble, so we can continue with the full dataset.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  dplyr::mutate(\n    component_name = factor(component_name, levels = significant)\n  ) |>\n  dplyr::group_by(component_name) |>\n  dplyr::mutate(\n    ctrl_median = median(abundance[group == \"WT, Methoxy-\"], na.rm = TRUE),\n    abundance = abundance - ctrl_median\n  ) |>\n  dplyr::ungroup() |>\n  group_by(group, panel) |>\n  heatmap(.row = component_name,\n          .column = sample_id, \n          .value = abundance, \n          column_title = \"Xia et al: targeted LC/MS data\",\n          row_title = \"Analyte\",\n          cluster_columns = FALSE,\n          cluster_rows = FALSE,\n          show_column_names = FALSE,\n          row_names_gp = grid::gpar(fontsize = 6),\n          palette_value = colors,\n           palette_grouping = list(\n            palette.colors(2, \"Set1\"),\n            c(\"darkgrey\", \"orange\", \"firebrick\")\n        )\n  ) |>\n  annotation_tile(\n    batch, \n    palette = RColorBrewer::brewer.pal(3, \"Dark2\"),\n    size = grid::unit(10, \"points\")\n  ) |>\n  annotation_tile(\n    sex, \n    palette = c(\"skyblue\", \"pink\"),\n    size = grid::unit(10, \"points\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=720}\n:::\n:::\n\n\nWe also added the `row_names_gp = grid::gpar(fontsize = 6)` argument to the\n`heatmap()` call, increasing the font size of the row labels. (They are still\na bit on the small side, so you might want to consider labelling only a subset.)\n\n## Reproducibility\n\n<details>\n<summary>\nSession information\n</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.11.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.11.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Los_Angeles\ntzcode source: system (glibc)\n\nattached base packages:\n[1] grid      stats     graphics  grDevices datasets  utils     methods  \n[8] base     \n\nother attached packages:\n[1] tidyr_1.3.1        readxl_1.4.3       checkmate_2.3.2    tidyHeatmap_1.10.2\n[5] tibble_3.2.1       RColorBrewer_1.1-3 ragg_1.3.3         dplyr_1.1.4       \n[9] circlize_0.4.16   \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5          shape_1.4.6.1         rjson_0.2.23         \n [4] xfun_0.37             ggplot2_3.5.1         htmlwidgets_1.6.1    \n [7] GlobalOptions_0.1.2   bspm_0.5.5            vctrs_0.6.5          \n[10] tools_4.3.2           generics_0.1.3        stats4_4.3.2         \n[13] parallel_4.3.2        fansi_1.0.6           cluster_2.1.6        \n[16] pkgconfig_2.0.3       S4Vectors_0.40.2      lifecycle_1.0.3      \n[19] compiler_4.3.2        farver_2.1.2          textshaping_0.4.0    \n[22] munsell_0.5.1         codetools_0.2-19      ComplexHeatmap_2.18.0\n[25] clue_0.3-65           htmltools_0.5.4       yaml_2.3.7           \n[28] pillar_1.9.0          crayon_1.5.3          iterators_1.0.14     \n[31] viridis_0.6.5         foreach_1.5.2         tidyselect_1.2.1     \n[34] digest_0.6.31         purrr_1.0.2           fastmap_1.1.1        \n[37] colorspace_2.1-1      cli_3.6.3             magrittr_2.0.3       \n[40] patchwork_1.3.0       utf8_1.2.4            withr_3.0.1          \n[43] backports_1.5.0       scales_1.3.0          rmarkdown_2.20       \n[46] matrixStats_1.4.1     gridExtra_2.3         cellranger_1.1.0     \n[49] png_0.1-8             GetoptLong_1.0.5      evaluate_0.20        \n[52] knitr_1.42            IRanges_2.36.0        doParallel_1.0.17    \n[55] viridisLite_0.4.2     rlang_1.1.4           dendextend_1.18.0    \n[58] glue_1.6.2            BiocManager_1.30.25   renv_1.0.11          \n[61] BiocGenerics_0.48.1   rstudioapi_0.14       jsonlite_1.8.4       \n[64] R6_2.5.1              systemfonts_1.1.0    \n```\n\n\n:::\n:::\n\n\n</details>\n   ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}