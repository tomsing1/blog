<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.36">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Thomas Sandmann">
<meta name="dcterms.date" content="2024-12-23">

<title>Compressing single-cell RNA-seq data with run-length encoding and LZW – Thomas Sandmann’s blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-01c78b5cd655e4cd89133cf59d535862.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-474c6d7e63be50eb6972897072b39b27.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-fd074d1f3eae4c6c63845f7c4c0fb288.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-0b08c4706a376d5bbb3674841d6c1774.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Thomas Sandmann’s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tomsing1"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/thomas-sandmann/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://genomic.social/@thomas_sandmann"> <i class="bi bi-mastodon" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Compressing single-cell RNA-seq data with run-length encoding and LZW</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i></button></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">R</div>
                <div class="quarto-category">single-cell</div>
                <div class="quarto-category">RNA-seq</div>
                <div class="quarto-category">algorithms</div>
                <div class="quarto-category">TIL</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Thomas Sandmann </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 23, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#tldr" id="toc-tldr" class="nav-link active" data-scroll-target="#tldr">tl;dr</a></li>
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#sparse-information-single-cell-rna-seq-data" id="toc-sparse-information-single-cell-rna-seq-data" class="nav-link" data-scroll-target="#sparse-information-single-cell-rna-seq-data">Sparse information: single-cell RNA-seq data</a></li>
  <li><a href="#run-length-encoding" id="toc-run-length-encoding" class="nav-link" data-scroll-target="#run-length-encoding">Run length encoding</a></li>
  <li><a href="#lzw-compression" id="toc-lzw-compression" class="nav-link" data-scroll-target="#lzw-compression">LZW compression</a>
  <ul>
  <li><a href="#lzw-encoding" id="toc-lzw-encoding" class="nav-link" data-scroll-target="#lzw-encoding">LZW encoding</a></li>
  <li><a href="#lzw-decoding" id="toc-lzw-decoding" class="nav-link" data-scroll-target="#lzw-decoding">LZW decoding</a></li>
  </ul></li>
  <li><a href="#so-what" id="toc-so-what" class="nav-link" data-scroll-target="#so-what">So what?</a></li>
  <li><a href="#reproducibility" id="toc-reproducibility" class="nav-link" data-scroll-target="#reproducibility">Reproducibility</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">tl;dr</h2>
<ul>
<li>Today I learned how to compress integer vectors using <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding (RLE)</a>, output the runs as character vectors, and create a basic implementation of the <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">Lempel-Ziv-Welch (LZW)</a> compression algorithm.</li>
<li>Together, these approaches reduce the amount of information that needs to be stored, e.g.&nbsp;in HTML reports, for interactive visualizations.</li>
<li>Hat tip to analysis reports generated by <a href="https://support.parsebiosciences.com/hc/en-us/articles/27066395947412-How-Do-I-Analyze-my-Parse-Biosciences-Data">Parse Bioscience’s analysis pipeline</a> where I spotted compressed single-cell RNA-seq data for the first time.</li>
</ul>
</section>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>I am always looking for ways to communicate genomics analyses to collaborators in a way that allows them to drill down into the data themselves. Stand-alone HTML reports can be opened in any web browser and can support rich visualizations, making them my an indespensible tool in my tool kit.</p>
<p>Yet, some of the data I am working with, e.g.&nbsp;single-cell RNA-seq data, is pretty large, and the size of my HTML reports - which include the data as text - can quickly balloon. Luckily, there are ways to compress numerical data without loosing information.</p>
<p>Here, I am exploring two approaches: <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding (RLE)</a> and <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">Lempel-Ziv-Welch (LZW) compression</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
</section>
<section id="sparse-information-single-cell-rna-seq-data" class="level2">
<h2 class="anchored" data-anchor-id="sparse-information-single-cell-rna-seq-data">Sparse information: single-cell RNA-seq data</h2>
<p>Single-cell RNA-seq data are notoriously sparse, e.g.&nbsp;the majority of counts across genes &amp; cells is zero. For example, 96% of all counts in the PBMC 4k single-cell experiment shared by 10X Genomics (and available via the <a href="https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html">TENxPBMCData</a> Bioconductor package) are zero:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(TENxPBMCData)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>tenx_pbmc4k <span class="ot">&lt;-</span> <span class="fu">suppressMessages</span>(<span class="fu">TENxPBMCData</span>(<span class="at">dataset =</span> <span class="st">"pbmc4k"</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">counts</span>(tenx_pbmc4k) <span class="sc">==</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.9608314</code></pre>
</div>
</div>
<p>Most of the remaining counts are integers smaller than ten, with fewer than 0.2% of values exceeding that range:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">counts</span>(tenx_pbmc4k) <span class="sc">&gt;</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.002338497</code></pre>
</div>
</div>
<p>This leads to very long runs of identical integers (most often zero), which can efficiently be represented through <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a></p>
<p>For example, the expression of the transcription facto <em>MYC</em> gene is highly skewed towards zero counts:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>myc <span class="ot">&lt;-</span> <span class="fu">local</span>({</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  ensembl <span class="ot">&lt;-</span> <span class="fu">row.names</span>(tenx_pbmc4k)[<span class="fu">which</span>(<span class="fu">rowData</span>(tenx_pbmc4k)<span class="sc">$</span>Symbol <span class="sc">==</span> <span class="st">"MYC"</span>)]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">counts</span>(tenx_pbmc4k)[ensembl, ]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(myc, <span class="at">breaks =</span> <span class="dv">100</span>, <span class="at">xlab =</span> <span class="st">"MYC (raw counts)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>and there are long sequences of zeros and some shorter sequences of ones in the count vector. (Here, I am only showing counts for the the first 100 of the 4340 cells.)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(myc, <span class="at">n =</span> <span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  [1] 0 0 0 1 3 0 0 0 1 0 0 0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
 [38] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 1 0 0 0
 [75] 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0</code></pre>
</div>
</div>
<p>R estimates that the entire vector of 4340 counts occupies 17 KiB of memory.</p>
</section>
<section id="run-length-encoding" class="level2">
<h2 class="anchored" data-anchor-id="run-length-encoding">Run length encoding</h2>
<p>This information can be communicated more concisely by noting each integer (e.g. zero) and the number of times it is repeated. The <code>stats::rle</code> function performs this conversion:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>run_lengths <span class="ot">&lt;-</span> <span class="fu">rle</span>(myc)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>run_lengths</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Run Length Encoding
  lengths: int [1:1195] 3 1 1 3 1 4 3 3 2 14 ...
  values : int [1:1195] 0 1 3 0 1 0 1 0 1 0 ...</code></pre>
</div>
</div>
<p>and returns two components:</p>
<ol type="1">
<li>a vector of values:</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(run_lengths<span class="sc">$</span>values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0 1 3 0 1 0</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>a vector with the number of times each of them is repeated:</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(run_lengths<span class="sc">$</span>lengths)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3 1 1 3 1 4</code></pre>
</div>
</div>
<p>This allows us to compress the original 4340 integers into 2390 integers (1195 length &amp; value pairs), without losing any information.</p>
<p>By combining information about values and run-lengths, we can reconstruct the original vector, either manually:</p>
<pre><code>0 x 3: 0,0,0,
1 x 1: 1,
3 x 1: 3,
0 x 3: 0,0,0,
1 x 1: 1,
0 x 4: 0,0,0,0,
1 x 3: 1,1,1,
...

=&gt; 0,0,0,1,3,0,0,0,1,0,0,0,0,1,1,1,...</code></pre>
<p>or via <code>inverse.rle</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">inverse.rle</span>(run_lengths), <span class="at">n =</span> <span class="dv">16</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0 0 0 1 3 0 0 0 1 0 0 0 0 1 1 1</code></pre>
</div>
</div>
<p>To store run-length encoded values e.g.&nbsp;in a text (or HTML) file, we can also represent them as characters, similar to our manual reconstruction above, e.g. separating values and lengths with an <code>x</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>myc_rle_separated <span class="ot">&lt;-</span> <span class="fu">mapply</span>(paste, </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    run_lengths<span class="sc">$</span>values, </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    run_lengths<span class="sc">$</span>length, </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">MoreArgs =</span> <span class="fu">list</span>(<span class="at">sep =</span> <span class="st">"x"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">paste</span>(<span class="at">collapse =</span> <span class="st">";"</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(myc_rle_separated, <span class="dv">1</span>, <span class="dv">40</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "0x3;1x1;3x1;0x3;1x1;0x4;1x3;0x3;1x2;0x14"</code></pre>
</div>
</div>
<p>This representation occupies only 4.9 KiB of memory - but <em>half</em> of the character string is required to encode the <code>x</code> and <code>;</code> separators. We can do better!</p>
<p>To avoid including any separators, we can represent one of the numbers, e.g.&nbsp;the values, as a single character instead. For the <em>MYC</em> gene, the largest observed integer count is 7. So let’s represent all 8 values (including 0) with a letter of the alphabet instead:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(letters[<span class="dv">1</span><span class="sc">:</span>(<span class="fu">max</span>(myc) <span class="sc">+</span> <span class="dv">1</span>)], <span class="dv">0</span><span class="sc">:</span><span class="fu">max</span>(myc))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>dictionary</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  0   1   2   3   4   5   6   7 
"a" "b" "c" "d" "e" "f" "g" "h" </code></pre>
</div>
</div>
<p>For example, the letter <code>a</code> represents <code>0</code>, <code>b</code> represents <code>1</code> and so on.</p>
<p>Now we can omit the <code>x</code> and <code>;</code> separators, as each run is unambiguously represented by one character and an integer <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-12"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-12-1"><a href="#annotated-cell-12-1" aria-hidden="true" tabindex="-1"></a>myc_rle_character <span class="ot">&lt;-</span> <span class="fu">mapply</span>(paste0, </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-12-2" class="code-annotation-target"><a href="#annotated-cell-12-2" aria-hidden="true" tabindex="-1"></a>    dictionary[<span class="fu">as.character</span>(run_lengths<span class="sc">$</span>values)],</span>
<span id="annotated-cell-12-3"><a href="#annotated-cell-12-3" aria-hidden="true" tabindex="-1"></a>    run_lengths<span class="sc">$</span>length) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-12-4"><a href="#annotated-cell-12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">paste</span>(<span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="annotated-cell-12-5"><a href="#annotated-cell-12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(myc_rle_character, <span class="dv">1</span>, <span class="dv">21</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-12" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="2" data-code-annotation="1">It’s critical to coerce the run-length values into a <em>character</em> vector here, otherwise the named vector is subset by <em>position</em> instead of by <em>name</em>.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a3b1d1a3b1a4b3a3b2a14"</code></pre>
</div>
</div>
<p>In this representation, the 4340 counts value for the <em>MYC</em> gene now occupy only 2.6 KiB of memory instead of the original 17 KiB. We can also write the data to a text (or HTML) file in this format, e.g.&nbsp;as a single string.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Encoding larger numbers of values
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this example, we only needed 8 letters to encode all observed unique counts for the <em>MYC</em> gene. But for other genes, especially those expressed at higher levels, we might observe many more possible values - even more than the 26 lower case letters of the English alphabet.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>gapdh <span class="ot">&lt;-</span> <span class="fu">local</span>({</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  ensembl <span class="ot">&lt;-</span> <span class="fu">row.names</span>(tenx_pbmc4k)[</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">which</span>(<span class="fu">rowData</span>(tenx_pbmc4k)<span class="sc">$</span>Symbol <span class="sc">==</span> <span class="st">"GAPDH"</span>)]</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">counts</span>(tenx_pbmc4k)[ensembl, ]</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For example, in this dataset we observe 59 distinct count values for the highly abundant <em>GAPDH</em> gene:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(gapdh)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>gapdh
  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 
485 683 708 572 430 302 216 146 118 122  85  56  58  44  40  22  24  25  16  13 
 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39 
 18  15  11  10  13   4   6   4  10   4   8   4   4   7   6   1   5   7   2   2 
 40  41  42  44  46  48  49  50  52  53  54  56  57  61  70  75  85  92 181 
  5   4   1   4   1   2   1   2   2   1   2   1   1   2   1   1   1   1   1 </code></pre>
</div>
</div>
<p>Luckily, we are not restricted to the English alphabet. For example, we can map to any character in the <a href="https://en.wikipedia.org/wiki/UTF-8">Unicode Transformation Format – 8-bit (UTF-8)</a> character encoding instead.</p>
<p>To encode e.g.&nbsp;all integers from 1 to 256 (more than enough for <em>GAPDH</em>) - but <em>avoiding those that represent a space, quote, etc or integers</em> - we can use UTF-8 codes 64 to 319:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>codes <span class="ot">&lt;-</span> <span class="dv">64</span><span class="sc">:</span><span class="dv">319</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">intToUtf8</span>(codes, <span class="at">multiple =</span> <span class="cn">TRUE</span>), <span class="dv">0</span><span class="sc">:</span><span class="dv">255</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(dictionary, <span class="at">n =</span> <span class="dv">66</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       0        1        2        3        4        5        6        7 
     "@"      "A"      "B"      "C"      "D"      "E"      "F"      "G" 
       8        9       10       11       12       13       14       15 
     "H"      "I"      "J"      "K"      "L"      "M"      "N"      "O" 
      16       17       18       19       20       21       22       23 
     "P"      "Q"      "R"      "S"      "T"      "U"      "V"      "W" 
      24       25       26       27       28       29       30       31 
     "X"      "Y"      "Z"      "["     "\\"      "]"      "^"      "_" 
      32       33       34       35       36       37       38       39 
     "`"      "a"      "b"      "c"      "d"      "e"      "f"      "g" 
      40       41       42       43       44       45       46       47 
     "h"      "i"      "j"      "k"      "l"      "m"      "n"      "o" 
      48       49       50       51       52       53       54       55 
     "p"      "q"      "r"      "s"      "t"      "u"      "v"      "w" 
      56       57       58       59       60       61       62       63 
     "x"      "y"      "z"      "{"      "|"      "}"      "~"   "\177" 
      64       65 
"\u0080" "\u0081" </code></pre>
</div>
</div>
<p>And then use this dictionary to encode the <em>GAPDH</em> counts:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gapdh, <span class="at">n =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  4  5  1  2  1  2  3 26  2 13  1  5  2  3 24  4  3  3  9  9</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>gapdh_character <span class="ot">&lt;-</span> <span class="fu">local</span>({</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  run_lengths <span class="ot">&lt;-</span> <span class="fu">rle</span>(gapdh)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapply</span>(paste0, </span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>         dictionary[<span class="fu">as.character</span>(run_lengths<span class="sc">$</span>values)],</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>         run_lengths<span class="sc">$</span>length) <span class="sc">|&gt;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">paste0</span>(<span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(gapdh_character, <span class="dv">1</span>, <span class="dv">36</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "D1E1A1B1A1B1C1Z1B1M1A1E1B1C1X1D1C2I2"</code></pre>
</div>
</div>
<p>Because there are more (and shorter) runs in the <em>GAPDH</em> count vector than for <em>MYC</em>, the degree of compression we achieve is smaller, from 17 KiB for the original count vector to 7.8 KiB for the character representation.</p>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In this post, the example dictionaries encode counts up to 256 - but many single-cell experiments will contain larger integer counts than 256.</p>
<p>For those, we either need to create a larger dictionary, or we could opt to truncate larger values (e.g.&nbsp;represent counts &gt;= 256 with the same character, losing information in the process).</p>
<p>When visualizing gene expression scores, we often log2 transform the raw or normalized counts, generating floating point numbers. If it is acceptable to lose precision, we can round these log2 transformed scores to the nearest integer and apply run-length encoding to them.</p>
<p>Because 2 to the power of 256 is a very large number (~ 1.16e+77), we would be able to represent even the highest observed scores But on the flip side, rounding the log2 transformed scores would obscure some differences between expression levels.</p>
</div>
</div>
</div>
</section>
<section id="lzw-compression" class="level2">
<h2 class="anchored" data-anchor-id="lzw-compression">LZW compression</h2>
<p>At this point, we are representing the original count vectors as character strings. Some of these string representation contain repeated patterns, which we can exploit to compress them even further.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The <code>Lempel–Ziv–Welch</code> algorithm was the <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">first widely used universal data compression method</a> and is e.g.&nbsp;used in the GIF image format.</p>
<p>At a high level, the algorithm identifies the longest repeated sequences (“phrases”) in a character string and maps them to shorter expressions in a dictionary.</p>
</div>
</div>
</div>
<p>There are great tutorials about the LZW algorithm and its implementation available on the web, e.g.&nbsp; <a href="https://eng.libretexts.org/Bookshelves/Electrical_Engineering/Signal_Processing_and_Modeling/Information_and_Entropy_(Penfield)/03%3A_Compression/3.07%3A_Detail-_LZW_Compression/3.7.01%3A_LZW_Algorithm_Example_1">this one</a>. Here, I will create a basic implementation in R <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<section id="lzw-encoding" class="level3">
<h3 class="anchored" data-anchor-id="lzw-encoding">LZW encoding</h3>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-13"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-13-1"><a href="#annotated-cell-13-1" aria-hidden="true" tabindex="-1"></a>compress_lzw <span class="ot">&lt;-</span> <span class="cf">function</span>(input_string) {</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-13-2" class="code-annotation-target"><a href="#annotated-cell-13-2" aria-hidden="true" tabindex="-1"></a>  dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>),</span>
<span id="annotated-cell-13-3"><a href="#annotated-cell-13-3" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>)</span>
<span id="annotated-cell-13-4"><a href="#annotated-cell-13-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="annotated-cell-13-5"><a href="#annotated-cell-13-5" aria-hidden="true" tabindex="-1"></a>  next_code <span class="ot">&lt;-</span> <span class="dv">257</span></span>
<span id="annotated-cell-13-6"><a href="#annotated-cell-13-6" aria-hidden="true" tabindex="-1"></a>  </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-13-7" class="code-annotation-target"><a href="#annotated-cell-13-7" aria-hidden="true" tabindex="-1"></a>  previous_pattern <span class="ot">&lt;-</span> <span class="fu">character</span>(<span class="dv">0</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-13-8" class="code-annotation-target"><a href="#annotated-cell-13-8" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> <span class="fu">character</span>(<span class="dv">0</span>)</span>
<span id="annotated-cell-13-9"><a href="#annotated-cell-13-9" aria-hidden="true" tabindex="-1"></a>  </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-13-10" class="code-annotation-target"><a href="#annotated-cell-13-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (char <span class="cf">in</span> <span class="fu">strsplit</span>(input_string, <span class="st">""</span>)[[<span class="dv">1</span>]]) {</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-13-11" class="code-annotation-target"><a href="#annotated-cell-13-11" aria-hidden="true" tabindex="-1"></a>    new_pattern <span class="ot">&lt;-</span> <span class="fu">paste0</span>(previous_pattern, char)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-13-12" class="code-annotation-target"><a href="#annotated-cell-13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (new_pattern <span class="sc">%in%</span> <span class="fu">names</span>(dictionary)) {</span>
<span id="annotated-cell-13-13"><a href="#annotated-cell-13-13" aria-hidden="true" tabindex="-1"></a>      previous_pattern <span class="ot">&lt;-</span> new_pattern</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-13" data-target-annotation="7" onclick="event.preventDefault();">7</a><span id="annotated-cell-13-14" class="code-annotation-target"><a href="#annotated-cell-13-14" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="annotated-cell-13-15"><a href="#annotated-cell-13-15" aria-hidden="true" tabindex="-1"></a>      output <span class="ot">&lt;-</span> <span class="fu">paste0</span>(output, dictionary[[previous_pattern]])</span>
<span id="annotated-cell-13-16"><a href="#annotated-cell-13-16" aria-hidden="true" tabindex="-1"></a>      dictionary[[new_pattern]] <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="fu">intToUtf8</span>(next_code))</span>
<span id="annotated-cell-13-17"><a href="#annotated-cell-13-17" aria-hidden="true" tabindex="-1"></a>      next_code <span class="ot">&lt;-</span> next_code <span class="sc">+</span> <span class="dv">1</span></span>
<span id="annotated-cell-13-18"><a href="#annotated-cell-13-18" aria-hidden="true" tabindex="-1"></a>      previous_pattern <span class="ot">&lt;-</span> char</span>
<span id="annotated-cell-13-19"><a href="#annotated-cell-13-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="annotated-cell-13-20"><a href="#annotated-cell-13-20" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="annotated-cell-13-21"><a href="#annotated-cell-13-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="annotated-cell-13-22"><a href="#annotated-cell-13-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">nzchar</span>(previous_pattern)) {</span>
<span id="annotated-cell-13-23"><a href="#annotated-cell-13-23" aria-hidden="true" tabindex="-1"></a>    output <span class="ot">&lt;-</span> <span class="fu">paste0</span>(output, dictionary[[previous_pattern]])</span>
<span id="annotated-cell-13-24"><a href="#annotated-cell-13-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="annotated-cell-13-25"><a href="#annotated-cell-13-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(output)</span>
<span id="annotated-cell-13-26"><a href="#annotated-cell-13-26" aria-hidden="true" tabindex="-1"></a>}</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-13" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="2" data-code-annotation="1">We initialize a “dictionary” (e.g.&nbsp;a named character vector) with 256 UTF-8 codes.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="7" data-code-annotation="2">As we parse the input string, the current sequence will be stored in the <code>previous_pattern</code> variable. It is initialized as an empty string.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="8" data-code-annotation="3">The <code>output</code> variable will collect the compressed output and is eventually returned. It is also initialized as an empty string.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="10" data-code-annotation="4">The input string is split into individual characters, and we process them one by one.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="11" data-code-annotation="5">In the first loop, the <code>previous_pattern</code> is still empty. But in subsequent loops, we extend the previous one with the new character to identify longer patterns.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="12" data-code-annotation="6">If the extended pattern is already known, then we don’t need to update our dictionary. We simply replace the <code>previous_pattern</code> with the current one.</span>
</dd>
<dt data-target-cell="annotated-cell-13" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-13" data-code-lines="14,15" data-code-annotation="7">If we encounter a <em>new</em> pattern, then we</span>
</dd>
</dl>
</div>
</div>
<ul>
<li>Encode the <code>previous_pattern</code> and add it to the output</li>
<li>Map the new pattern to the next available UTF-8 code</li>
<li>Increment the position of the next available UTF-8 code by one</li>
<li>Reset the previous pattern to the current character.</li>
</ul>
<ol start="8" type="1">
<li>After the entire string has been processed, we encode the final pattern and then return the full output.</li>
</ol>
<p>Let’s apply our LZW compression function to the run-length encoded <em>MYC</em> expression we generated above:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>myc_lzw <span class="ot">&lt;-</span> <span class="fu">compress_lzw</span>(myc_rle_character)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>myc_lzw</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a3b1d1āăa4b3ć2a1ĊĆ1ĂĒ7ăcĒĈ6Ĉ8Ĉ9Ĉ1ĞėĆ2bĎđa5ĈĪħīĈĖĆ6ąa2ĳ5ĘďĈĥıĦĉĔĴ2ĘĠŁĤĚįĠ0ĮĆ3ĸ1ĸ6ōŃĸĪĒġĒōĿŔĹĒěĆğĎ9ōłĎŚ1ŖĉĺĠĺfĆĨĨŧēĽĝŋœĽĿ20eŭōĻćŴŅĕżŪĒĨ7ąĚĳŰğŋĈ4őĆŚƋāĶĽŰĽƎĆİŨŋŎŕũŭƟĩłŗļıĸƘĩĽŽĖĎŐƥď0Əďŧŝžďĸ3ƇƠĤƵ5ĳěČ8ƸŇĒŉƐŊďƒƒ1ŚĲƀưƈƌſĺƵ7ƣĴƍƃƧƃď4ąĸŽǂǏŧǞƞƌ4aǋhƌĎǢaƵƴĘĳĨ8ƺƩħǠĳǋĿŧĻcĎƝǘĤƲ1ŽƵ2ŚųśȂďǺĚǠǙǅĈŷĜǜŦȕęĒķƐţĴŚƆƐźĴȝŚůƵȇăgǽŪĭƙũƭĠŧĝĎƚƬƛƓȒĆȳȞŃņȜĕňĠœĳǖƻƩȮȿƉȾĴǆȌťɍěȀĳƹȚīǗǋŒļȭȸƶƚȁŌǤĸƚůůȁɣƸǳȱīȢƮĴɅďťĨĬɰĽƾȫɀƻɊƯĂȀƗĞǶĿǼƣǠǠƘȽɛȊɷďȻɯɔƪƂĤĨ3ƅģȷŰǗǕŏǛȹȋȊ3ȪǃșaʞĢ1ȢɠƶűǒƶƒĥĎǼįȐĤǶɣơɤȘʣȱōɍțāŢŧɯŽǤȑȌŽʔȁȁ˂ĺĳĵɆɞǡăŬʾ1ȪȋȅżʛƳȖĠȉƉġĎŽʭȖŧɏʕŽŷ2źơ1ƱǏńžʧʸˬȓȖĨ23˪ſȷƫœƏǗ˟ĉōˈȊ˧ʲƶ˷ōƵʨĔ̉˄ŖʚǣɍŽ̓ƕ˶Ȗŏɪęʯĺɍ3ǎƷǏȊƅʡư˒ĄƄŶ˫ǋɑď˱ŅȰ˺ȔȿȌǀƶ̬˂ʿďɭŚƑơǋŧʨ̬ġʨŚɼaİĸƒʤʢ̤͋ǍƧǶȊ5ǫōźƇȀʨʭƉɯ˃ǇĒʨˡȕČĿɭǌ˄̄ǶʊǵɆ˳ŻŜɋȗŞȢĊɛŷɍˤăƔƠČƵƎɽ̳̱ͦơ̸ĤȢ̔ŭ˂5ͳȖͤ˫ɐʥɇɜȊş˖Ǽ̀Ίͯŋǡͺʩ̲ǩįƿȽĒĥČɷˌǜʉ\u03a2ɜƨ˸ȃƤȣʫ\u0378ŋƉ0ȎɕƯ6"</code></pre>
</div>
</div>
<p>After LZW compression, R estimates the size of this new character representation to be 1.4 KiB, down from 2.6 KiB after RLE.</p>
<p>Next, let’s implement the corresponding decoding function!</p>
</section>
<section id="lzw-decoding" class="level3">
<h3 class="anchored" data-anchor-id="lzw-decoding">LZW decoding</h3>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-15"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-15-1"><a href="#annotated-cell-15-1" aria-hidden="true" tabindex="-1"></a>decompress_lzw <span class="ot">&lt;-</span> <span class="cf">function</span>(compressed) {</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-15-2" class="code-annotation-target"><a href="#annotated-cell-15-2" aria-hidden="true" tabindex="-1"></a>  dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>),</span>
<span id="annotated-cell-15-3"><a href="#annotated-cell-15-3" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>)</span>
<span id="annotated-cell-15-4"><a href="#annotated-cell-15-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="annotated-cell-15-5"><a href="#annotated-cell-15-5" aria-hidden="true" tabindex="-1"></a>  next_code <span class="ot">&lt;-</span> <span class="dv">257</span></span>
<span id="annotated-cell-15-6"><a href="#annotated-cell-15-6" aria-hidden="true" tabindex="-1"></a>  </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-15-7" class="code-annotation-target"><a href="#annotated-cell-15-7" aria-hidden="true" tabindex="-1"></a>  compressed_codes <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(compressed, <span class="st">""</span>)[[<span class="dv">1</span>]]</span>
<span id="annotated-cell-15-8"><a href="#annotated-cell-15-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># read the first character and decode it</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-15-9" class="code-annotation-target"><a href="#annotated-cell-15-9" aria-hidden="true" tabindex="-1"></a>  current_code <span class="ot">&lt;-</span> compressed_codes[<span class="dv">1</span>]</span>
<span id="annotated-cell-15-10"><a href="#annotated-cell-15-10" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> dictionary[[current_code]] </span>
<span id="annotated-cell-15-11"><a href="#annotated-cell-15-11" aria-hidden="true" tabindex="-1"></a>  previous_string <span class="ot">&lt;-</span> output</span>
<span id="annotated-cell-15-12"><a href="#annotated-cell-15-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="annotated-cell-15-13"><a href="#annotated-cell-15-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># read the remaining characters, one by one</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-15-14" class="code-annotation-target"><a href="#annotated-cell-15-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (code <span class="cf">in</span> compressed_codes[<span class="sc">-</span><span class="dv">1</span>]) {</span>
<span id="annotated-cell-15-15"><a href="#annotated-cell-15-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">as.character</span>(code) <span class="sc">%in%</span> <span class="fu">names</span>(dictionary)) {</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-15" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-15-16" class="code-annotation-target"><a href="#annotated-cell-15-16" aria-hidden="true" tabindex="-1"></a>      current_string <span class="ot">&lt;-</span> dictionary[<span class="fu">as.character</span>(code)]</span>
<span id="annotated-cell-15-17"><a href="#annotated-cell-15-17" aria-hidden="true" tabindex="-1"></a>      dictionary[[<span class="fu">intToUtf8</span>(next_code)]] <span class="ot">&lt;-</span> <span class="fu">paste0</span>(previous_string, </span>
<span id="annotated-cell-15-18"><a href="#annotated-cell-15-18" aria-hidden="true" tabindex="-1"></a>                                                   <span class="fu">substr</span>(current_string, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="annotated-cell-15-19"><a href="#annotated-cell-15-19" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="annotated-cell-15-20"><a href="#annotated-cell-15-20" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="annotated-cell-15-21"><a href="#annotated-cell-15-21" aria-hidden="true" tabindex="-1"></a>      current_string <span class="ot">&lt;-</span> <span class="fu">paste0</span>(previous_string, <span class="fu">substr</span>(previous_string, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="annotated-cell-15-22"><a href="#annotated-cell-15-22" aria-hidden="true" tabindex="-1"></a>      dictionary[[<span class="fu">intToUtf8</span>(next_code)]] <span class="ot">&lt;-</span> current_string</span>
<span id="annotated-cell-15-23"><a href="#annotated-cell-15-23" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="annotated-cell-15-24"><a href="#annotated-cell-15-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="annotated-cell-15-25"><a href="#annotated-cell-15-25" aria-hidden="true" tabindex="-1"></a>    output <span class="ot">&lt;-</span> <span class="fu">paste0</span>(output, current_string)</span>
<span id="annotated-cell-15-26"><a href="#annotated-cell-15-26" aria-hidden="true" tabindex="-1"></a>    next_code <span class="ot">&lt;-</span> next_code <span class="sc">+</span> <span class="dv">1</span></span>
<span id="annotated-cell-15-27"><a href="#annotated-cell-15-27" aria-hidden="true" tabindex="-1"></a>    previous_string <span class="ot">&lt;-</span> current_string</span>
<span id="annotated-cell-15-28"><a href="#annotated-cell-15-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="annotated-cell-15-29"><a href="#annotated-cell-15-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(output)</span>
<span id="annotated-cell-15-30"><a href="#annotated-cell-15-30" aria-hidden="true" tabindex="-1"></a>}</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-15" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="2" data-code-annotation="1">The decoding function is provided with the same initial dictionary we included in the encoding function.</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="7" data-code-annotation="2">We process the compressed string one character at a time.</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="9" data-code-annotation="3">The algorithm is initialized with the first character of the encoded string, and we decode it using the pre-defined dictionary (which includes all single characters).</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="14" data-code-annotation="4">We then iterate over the remaining characters in the compressed input.</span>
</dd>
<dt data-target-cell="annotated-cell-15" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-15" data-code-lines="16" data-code-annotation="5">We check if the current code is already in our dictionary</span>
</dd>
</dl>
</div>
</div>
<ul>
<li>If <em>yes</em>, then we decode it by looking up its corresponding value in our dictionary. We also add an extended pattern to our dictionary, by concatenating the previous result with the (first character of) our current one.</li>
<li>If <em>no</em>, then we decode it by extending the previous result by its (own) first character and add it to the dictionary. character</li>
</ul>
<ol start="6" type="1">
<li>We add the newly decoded result to our output string.</li>
<li>Increment the running index of our dictionary, because we added a new key.</li>
<li>Get ready for the next iteration.</li>
</ol>
<p>Let’s test the function by restoring the RLE-encoded <em>MYC</em> counts we compressed above:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>myc_lzw_decompressed <span class="ot">&lt;-</span> <span class="fu">decompress_lzw</span>(myc_lzw)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(myc_lzw_decompressed)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a3b1d1a3b1a4b3a3b2a14b1a13b1a17b1c1a1b1a6b1a8b1a9b1a1b1a9b1c1a2b2a4b1a5b1a5b2a4b1a5b1a7b1a6d1a2d1a5c1a1b1a2b1a6b2a43b1a22c1b1a12c1a2b1a6b1a7b1a10b1a5b1a3c1a1c1a6c1a1b1a12c1a5b1a11b1a1c1a13b1a5b1a1b1a16b1a9b2a9c1a1c1b2a5b1a11b1a4b1a2b1a1b1a2f1a4b1a4b1a1b1a13b2a8b1a3c1a5b2a3b1a20e1a4c1a12b1a3b1a3c1a2b1a17c1a12b1a1b1a14b1a7d1b1a6d1a1b1a19b1a3b1a4c1a1b1a5b1a9b1a3d1a5b2a1b1a1b2a4c1a7b1a4b1a31c1a11b1a2b1a4b1a2b1a5c1b1a1c1a6b1a6c1a4c1a5b2a2b1a7b2a6c1a6b1a10c1a1b1a11b1a6b1a3b1a1c1a3d1b1a4b1a26b1a5d1a6b3a8c1a3b1a7b1a10b1a5b1a5b1a19b1a9b1a15b1a6d1a2b1a10b1a6d1a3b1a3c1b1a26b1a7c1b1a2b1a4b1a1b1c1a4b1a1b1a14d1c1a2b1a8c1a2b1a1b1a4d1a11b1a3b4a9b1a1h1a3b2a8c1a6b1a1b1a6c1d1a4b1a8d1b1a5b2a4c1a2d1a9b1a13b1a1b1a2b1c2a1c1a2b1a2c1a1b1a12b1a6b1a25b1a8b1a1b1a2b1a1d1a9b1a6c1a2b1a4b1a10b1a3b1a2b1a8b1a1b1a11b1a8b1a1b1a15c1a5c1b2a25b1a7d1a5e1a2c1b2a5b1a4b1a16b1a6b1a2b1g1b1a2b1a1b2a4b1a7b1a2b2a6b1a11b1a8b2a7b1a7b2a4b1a3d1a10b1a8b2a25b1a12b1a6b1a5c1a17b1a10b1a1c1a5d1a7c1a4b1a5b1a7b1a5c1d1a1b1a6b1a20b1a2b1a5b1a10b1a6b2a1d1a3d1a15b1a5c1b1a9b1a1b1a12c1a6b2a4b1a3d1a3b1a7b1a1c1a3c1b1a4c1a7b1a4b1a14b1a11c1a7b1a4c1a3d1a4b1a11b1a5e1a6c1a27c1a15b1a14b1a5b2a15b2a5d1b1a2b1a17b1a4b1d1a1b1a6b1a3b2a1b2a4b1a9d1b1a3b1a3b1a1c1b1c1a2c1a24c1b1a12b2a4b1a8b1a1b1a2b1a18b2a7c1a3d1b2a2c1a12b1a24b1a34b1a7b1c1a4b1a1b1a1c1b1a6b1a7c1a6c1a4b1a10b1a1b1a8b1a3g1c1a3b1a1b1a8b1a3b1a9b1e1a3c1a3b1a13b1a3b1a3b1a9b1a2b2a3b1a1b1a7c1a2b1a2d1b1a7b1a4b1a2b1a4b1a14b1a8b1a8b1a11c1a10b1a5c1a3c1a1c1b1a7c1a2b1a1b1a4b1a4b1a2b1a2b1a4b1a7b1c1a1c1a2b1a1b1a2d1a2d1a4b1a7b1a12b1a8b1f1a3c1g1a1b1a12c1a12c1a4b1a11b1a1b1a1b1a15b1a8d1a11b2a2b1a9b1a2b1a1b1a11b1a5b1a10b1c1a2b1a3b1a22e1b1a2b1a10c1a2b1a2c1a3b1e1a3b1a8b1a10b1a3b1a1b1a14b1a23e1b1a3c1a4b1a2b1a7c1a5c1a1b1c1b1a1b2a4c1a11c1a18b1a2b1a3c1a2b1a3b1a23c1a16b1a3c1a3b1c1a16b1a4b1a1b1c1a6c1a2b1a10b1a2b1a2b1a2b2a14b1a2b1a1b1a1c1a6b1a11b1a1b2a3b1a20b1a36d1a1c1a2b1a8b1a4b1a7c1a3b1a10f1a1d1a14b2a3b1a2b1a19b1a16b2a1e1a3b1a2b2a6b1a3c1a3b1a2b1a5c1a2b1a6b3a3b1a6b2a2b1a1c1a1c1a16c1a5b1a5b1a9b1a2b1a9b1a11b1a3c1a6b2a1b3c1a5b1a3b2a7b1c1a9b1a8b1a3b1a1b1a8b1a3b1c1a3b1a5b1a6c1a4d1b1a8b1a5h1c1a1e1d1b2a13c1a9b1a2d1a17c1a1b1a4b1a5b1a13c1a2b1a9b1a8b3a3b1a6c1a15b1a4b1a8b1a2d1b1a1b1a2b1a8d1a4b1a10b1a4c1a16b1a6b1a11b1a9e1a4b2a4b1a3b1a20b1a1b1a5b1d1a5b1a4b3a6b1a4c2a1b1a5c1a15b1a3c1a3b1a2b1a2b1a1c1a2e1a2b1a2b1a42b1a15e1a4b1a1b1a13b1a6b1a2b1a10b1a6b1a9b1a5b1a3d1a8b1a9b2a1b1a13b1a11b2a5e1a16b1a32b1a8d1a5b1a3b1a13b1a2b1a9b1a7d1a6b1a12b1a12b3a1b1a2b1d1a2b1a1b1a8b1a1b1a12b1a3d1a4c1a3e1a2c1a1c1a2c1a3b1a1b1a5b1a3d1a10d1a9b1a15b1a6b1a6"</code></pre>
</div>
</div>
<p>Are the results of sequention compression &amp; decompression really identical to the input string?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">identical</span>(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">decompress_lzw</span>(<span class="fu">compress_lzw</span>(myc_rle_character)), </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  myc_rle_character)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compression / decompression example
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Because it’s hard to visually compare the long vectors we have compressed &amp; decompressed above, here is a toy example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>original_string <span class="ot">&lt;-</span> <span class="st">"MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD"</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>compressed <span class="ot">&lt;-</span> <span class="fu">compress_lzw</span>(original_string)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>decompressed <span class="ot">&lt;-</span> <span class="fu">decompress_lzw</span>(compressed)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Original String:  MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD </code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Compressed:  MARYHADALITTLELAMBāăąćĉċčďđēĄĆ </code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Decompressed:  MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD </code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
</section>
<section id="so-what" class="level2">
<h2 class="anchored" data-anchor-id="so-what">So what?</h2>
<p>We have applied two rounds of compression to our count (or rounded, log2 transformed counts) single-cell RNA-seq data, achieving considerable reduction in the size of the objects <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>While I have created examples of RLE and LZW compression using R, the same approach can be implemented in any programming language. The reports generated by Parse Bioscience, for example <a href="https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#">this one</a>, include rounded log2 gene expression counts for all assayed genes across all cells that was compressed in the same way <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. To decode the compressed strings, the html reports include javascript functions that perform the same operations established here.</p>
<p>Combined with interactive plots, users can enter a gene name, triggering the decoding of its gene expression scores and updating a UMP plot in their browser - without the need for any central server. (Take a look at <a href="https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#">the source code of one of their reports</a> to see how this is achieved!)</p>
<p>Now that I have a better understanding of how large amounts of data can be included in a stand-along HTML document, I am ready to learn more about javascript &amp; interactive visualizations <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>!</p>
</section>
<section id="reproducibility" class="level2">
<h2 class="anchored" data-anchor-id="reproducibility">Reproducibility</h2>
<details>
<summary>
Session Information
</summary>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.4.1 (2024-06-14)
Platform: x86_64-pc-linux-gnu
Running under: Debian GNU/Linux 12 (bookworm)

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 
LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

time zone: America/Los_Angeles
tzcode source: system (glibc)

attached base packages:
[1] stats4    stats     graphics  grDevices datasets  utils     methods  
[8] base     

other attached packages:
 [1] TENxPBMCData_1.24.0         HDF5Array_1.34.0           
 [3] rhdf5_2.50.1                DelayedArray_0.32.0        
 [5] SparseArray_1.6.0           S4Arrays_1.6.0             
 [7] abind_1.4-8                 Matrix_1.7-0               
 [9] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0
[11] Biobase_2.66.0              GenomicRanges_1.58.0       
[13] GenomeInfoDb_1.42.1         IRanges_2.40.1             
[15] S4Vectors_0.44.0            BiocGenerics_0.52.0        
[17] MatrixGenerics_1.18.0       matrixStats_1.4.1          

loaded via a namespace (and not attached):
 [1] KEGGREST_1.46.0         xfun_0.49               lattice_0.22-6         
 [4] rhdf5filters_1.18.0     vctrs_0.6.5             tools_4.4.1            
 [7] generics_0.1.3          curl_6.0.1              AnnotationDbi_1.68.0   
[10] tibble_3.2.1            RSQLite_2.3.9           blob_1.2.4             
[13] pkgconfig_2.0.3         dbplyr_2.5.0            lifecycle_1.0.4        
[16] GenomeInfoDbData_1.2.13 compiler_4.4.1          Biostrings_2.74.1      
[19] htmltools_0.5.8.1       yaml_2.3.10             pillar_1.10.0          
[22] crayon_1.5.3            cachem_1.1.0            mime_0.12              
[25] ExperimentHub_2.14.0    AnnotationHub_3.14.0    tidyselect_1.2.1       
[28] digest_0.6.37           purrr_1.0.2             dplyr_1.1.4            
[31] BiocVersion_3.20.0      fastmap_1.2.0           grid_4.4.1             
[34] cli_3.6.3               magrittr_2.0.3          withr_3.0.2            
[37] rappdirs_0.3.3          filelock_1.0.3          UCSC.utils_1.2.0       
[40] bit64_4.5.2             rmarkdown_2.29          XVector_0.46.0         
[43] httr_1.4.7              bit_4.5.0.1             png_0.1-8              
[46] memoise_2.0.1           evaluate_1.0.1          knitr_1.49             
[49] BiocFileCache_2.14.0    rlang_1.1.4             glue_1.8.0             
[52] DBI_1.2.3               BiocManager_1.30.25     renv_1.0.11            
[55] jsonlite_1.8.9          R6_2.5.1                Rhdf5lib_1.28.0        
[58] zlibbioc_1.52.0        </code></pre>
</div>
</div>
</details>


<!-- -->

</section>


<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p><div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Both of these approaches are used e.g.&nbsp;in the summary HTML reports generated by Parse Bioscience’s analysis pipeline, e.g.&nbsp;in this <a href="https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#">example report</a>. The HTML file contains transcriptome-wide gene expression scores for &gt; 50,000 cells, and users can visualize the expression of their favorite gene on a UMAP projection. The whole HTML file is ~ 60 MB in size.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Because runs can be very long, the lengths - represented as integers - have varying number of decimals.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>While this implementation works, it could be improved. For example, it doesn’t set any limits on the size of the final dictionary.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Typical file formats used to exchange single-cell RNA-seq count tables are using more sophisticated ways of compression. For example, applying <a href="https://en.wikipedia.org/wiki/Gzip">gzip compression</a> to CSV files with sparse count data will reduce their sizes tremendously. Other formats, e.g.&nbsp; <code>HDF5</code> or <code>Parquet</code> files also take advantage of compression algorithms.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The encoding &amp; compression is happening when the report is generated, but the decoding javascript functions are part of the HTML report.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Greg Wilson’s <a href="https://third-bit.com/js4ds/">Javascript for Data Scientists</a> course has been on my to-do list for a while.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/tomsing1\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="tomsing1/blog" data-repo-id="R_kgDOIZ9LJw" data-category="Announcements" data-category-id="DIC_kwDOIZ9LJ84CTvnC" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark"><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb43" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Compressing single-cell RNA-seq data with run-length encoding and LZW"</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Thomas Sandmann"</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2024-12-23"</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="co">  echo: true</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="co">  warning: false</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="co">  message: false</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="an">freeze:</span><span class="co"> true</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [R, single-cell, RNA-seq, algorithms, TIL]</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="an">editor:</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="co">  markdown:</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="co">    wrap: 72</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="co">    anchor-sections: true</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 4</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools:</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a><span class="co">      source: true</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a><span class="co">      toggle: false</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a><span class="co">      caption: none</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a><span class="an">editor_options:</span><span class="co"> </span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a><span class="co">  chunk_output_type: console</span></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a><span class="co">#| include: false</span></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>renv<span class="sc">::</span><span class="fu">use</span>(<span class="at">lockfile =</span> <span class="fu">file.path</span>(<span class="fu">path.expand</span>(<span class="st">"~"</span>), <span class="st">"repositories"</span>, <span class="st">"blog"</span>, </span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>                               <span class="st">"posts"</span>, <span class="st">"lzw"</span>, <span class="st">"renv"</span>, <span class="st">"profiles"</span>, <span class="st">"lzw"</span>,</span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>                               <span class="st">"renv.lock"</span>))</span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## tl;dr</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Today I learned how to compress integer vectors using </span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">run-length encoding (RLE)</span><span class="co">](https://en.wikipedia.org/wiki/Run-length_encoding)</span>, </span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>output the runs as character vectors, and create a basic implementation</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>of the </span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Lempel-Ziv-Welch (LZW)</span><span class="co">](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>compression algorithm.</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Together, these approaches reduce the amount of information that needs to be</span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>stored, e.g. in HTML reports, for interactive visualizations.</span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Hat tip to analysis reports generated by </span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Parse Bioscience's analysis pipeline</span><span class="co">](https://support.parsebiosciences.com/hc/en-us/articles/27066395947412-How-Do-I-Analyze-my-Parse-Biosciences-Data)</span> where I spotted compressed single-cell RNA-seq data for the</span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>first time.</span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a><span class="fu">## Motivation</span></span>
<span id="cb43-51"><a href="#cb43-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-52"><a href="#cb43-52" aria-hidden="true" tabindex="-1"></a>I am always looking for ways to communicate genomics analyses to collaborators</span>
<span id="cb43-53"><a href="#cb43-53" aria-hidden="true" tabindex="-1"></a>in a way that allows them to drill down into the data themselves. Stand-alone</span>
<span id="cb43-54"><a href="#cb43-54" aria-hidden="true" tabindex="-1"></a>HTML reports can be opened in any web browser and can support rich </span>
<span id="cb43-55"><a href="#cb43-55" aria-hidden="true" tabindex="-1"></a>visualizations, making them my an indespensible tool in my tool kit. </span>
<span id="cb43-56"><a href="#cb43-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-57"><a href="#cb43-57" aria-hidden="true" tabindex="-1"></a>Yet, some of the data I am working with, e.g. single-cell RNA-seq data,</span>
<span id="cb43-58"><a href="#cb43-58" aria-hidden="true" tabindex="-1"></a>is pretty large, and the size of my HTML reports - which include the data </span>
<span id="cb43-59"><a href="#cb43-59" aria-hidden="true" tabindex="-1"></a>as text - can quickly balloon. Luckily, there are ways to compress numerical </span>
<span id="cb43-60"><a href="#cb43-60" aria-hidden="true" tabindex="-1"></a>data without loosing information. </span>
<span id="cb43-61"><a href="#cb43-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-62"><a href="#cb43-62" aria-hidden="true" tabindex="-1"></a>Here, I am exploring two approaches: </span>
<span id="cb43-63"><a href="#cb43-63" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">run-length encoding (RLE)</span><span class="co">](https://en.wikipedia.org/wiki/Run-length_encoding)</span> and </span>
<span id="cb43-64"><a href="#cb43-64" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Lempel-Ziv-Welch (LZW) compression</span><span class="co">](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)</span><span class="ot">[^1]</span>.</span>
<span id="cb43-65"><a href="#cb43-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-66"><a href="#cb43-66" aria-hidden="true" tabindex="-1"></a><span class="ot">[^1]: </span>Both of these approaches are used e.g. in the summary HTML reports</span>
<span id="cb43-67"><a href="#cb43-67" aria-hidden="true" tabindex="-1"></a>generated by Parse Bioscience's analysis pipeline, e.g. in this</span>
<span id="cb43-68"><a href="#cb43-68" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">example report</span><span class="co">](https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#)</span>.</span>
<span id="cb43-69"><a href="#cb43-69" aria-hidden="true" tabindex="-1"></a>The HTML file contains transcriptome-wide gene expression scores for &gt; 50,000</span>
<span id="cb43-70"><a href="#cb43-70" aria-hidden="true" tabindex="-1"></a>cells, and users can visualize the expression of their favorite gene on a </span>
<span id="cb43-71"><a href="#cb43-71" aria-hidden="true" tabindex="-1"></a>UMAP projection. The whole HTML file is ~ 60 MB in size.</span>
<span id="cb43-72"><a href="#cb43-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-73"><a href="#cb43-73" aria-hidden="true" tabindex="-1"></a><span class="fu">## Sparse information: single-cell RNA-seq data</span></span>
<span id="cb43-74"><a href="#cb43-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-75"><a href="#cb43-75" aria-hidden="true" tabindex="-1"></a>Single-cell RNA-seq data are notoriously sparse, e.g. the majority of counts</span>
<span id="cb43-76"><a href="#cb43-76" aria-hidden="true" tabindex="-1"></a>across genes &amp; cells is zero. For example, 96% of all counts in the PBMC 4k</span>
<span id="cb43-77"><a href="#cb43-77" aria-hidden="true" tabindex="-1"></a>single-cell experiment shared by 10X Genomics (and available via the </span>
<span id="cb43-78"><a href="#cb43-78" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">TENxPBMCData</span><span class="co">](https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html)</span></span>
<span id="cb43-79"><a href="#cb43-79" aria-hidden="true" tabindex="-1"></a>Bioconductor package) are zero:</span>
<span id="cb43-80"><a href="#cb43-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-83"><a href="#cb43-83" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-84"><a href="#cb43-84" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb43-85"><a href="#cb43-85" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb43-86"><a href="#cb43-86" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(TENxPBMCData)</span>
<span id="cb43-87"><a href="#cb43-87" aria-hidden="true" tabindex="-1"></a>tenx_pbmc4k <span class="ot">&lt;-</span> <span class="fu">suppressMessages</span>(<span class="fu">TENxPBMCData</span>(<span class="at">dataset =</span> <span class="st">"pbmc4k"</span>))</span>
<span id="cb43-88"><a href="#cb43-88" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">counts</span>(tenx_pbmc4k) <span class="sc">==</span> <span class="dv">0</span>)</span>
<span id="cb43-89"><a href="#cb43-89" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-90"><a href="#cb43-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-91"><a href="#cb43-91" aria-hidden="true" tabindex="-1"></a>Most of the remaining counts are integers smaller than ten, with fewer than</span>
<span id="cb43-92"><a href="#cb43-92" aria-hidden="true" tabindex="-1"></a>0.2% of values exceeding that range:</span>
<span id="cb43-93"><a href="#cb43-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-96"><a href="#cb43-96" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-97"><a href="#cb43-97" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">counts</span>(tenx_pbmc4k) <span class="sc">&gt;</span> <span class="dv">10</span>)</span>
<span id="cb43-98"><a href="#cb43-98" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-99"><a href="#cb43-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-100"><a href="#cb43-100" aria-hidden="true" tabindex="-1"></a>This leads to very long runs of identical integers (most often zero), which</span>
<span id="cb43-101"><a href="#cb43-101" aria-hidden="true" tabindex="-1"></a>can efficiently be represented through </span>
<span id="cb43-102"><a href="#cb43-102" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">run-length encoding</span><span class="co">](https://en.wikipedia.org/wiki/Run-length_encoding)</span></span>
<span id="cb43-103"><a href="#cb43-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-104"><a href="#cb43-104" aria-hidden="true" tabindex="-1"></a>For example, the expression of the transcription facto _MYC_ gene is highly</span>
<span id="cb43-105"><a href="#cb43-105" aria-hidden="true" tabindex="-1"></a>skewed towards zero counts:</span>
<span id="cb43-106"><a href="#cb43-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-109"><a href="#cb43-109" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-110"><a href="#cb43-110" aria-hidden="true" tabindex="-1"></a>myc <span class="ot">&lt;-</span> <span class="fu">local</span>({</span>
<span id="cb43-111"><a href="#cb43-111" aria-hidden="true" tabindex="-1"></a>  ensembl <span class="ot">&lt;-</span> <span class="fu">row.names</span>(tenx_pbmc4k)[<span class="fu">which</span>(<span class="fu">rowData</span>(tenx_pbmc4k)<span class="sc">$</span>Symbol <span class="sc">==</span> <span class="st">"MYC"</span>)]</span>
<span id="cb43-112"><a href="#cb43-112" aria-hidden="true" tabindex="-1"></a>  <span class="fu">counts</span>(tenx_pbmc4k)[ensembl, ]</span>
<span id="cb43-113"><a href="#cb43-113" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb43-114"><a href="#cb43-114" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(myc, <span class="at">breaks =</span> <span class="dv">100</span>, <span class="at">xlab =</span> <span class="st">"MYC (raw counts)"</span>)</span>
<span id="cb43-115"><a href="#cb43-115" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-116"><a href="#cb43-116" aria-hidden="true" tabindex="-1"></a>and there are long sequences of zeros and some shorter sequences of ones in</span>
<span id="cb43-117"><a href="#cb43-117" aria-hidden="true" tabindex="-1"></a>the count vector. (Here, I am only showing counts for the the first 100 of the </span>
<span id="cb43-118"><a href="#cb43-118" aria-hidden="true" tabindex="-1"></a><span class="in">`r ncol(tenx_pbmc4k)`</span> cells.) </span>
<span id="cb43-119"><a href="#cb43-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-122"><a href="#cb43-122" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-123"><a href="#cb43-123" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(myc, <span class="at">n =</span> <span class="dv">100</span>)</span>
<span id="cb43-124"><a href="#cb43-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-125"><a href="#cb43-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-126"><a href="#cb43-126" aria-hidden="true" tabindex="-1"></a>R estimates that the entire vector of <span class="in">`r length(myc)`</span> counts occupies </span>
<span id="cb43-127"><a href="#cb43-127" aria-hidden="true" tabindex="-1"></a><span class="in">`r format(object.size(myc), units = "KiB")`</span> of memory.</span>
<span id="cb43-128"><a href="#cb43-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-129"><a href="#cb43-129" aria-hidden="true" tabindex="-1"></a><span class="fu">## Run length encoding</span></span>
<span id="cb43-130"><a href="#cb43-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-131"><a href="#cb43-131" aria-hidden="true" tabindex="-1"></a>This information can be communicated more concisely by noting each integer (e.g.</span>
<span id="cb43-132"><a href="#cb43-132" aria-hidden="true" tabindex="-1"></a>zero) and the number of times it is repeated. The <span class="in">`stats::rle`</span> function</span>
<span id="cb43-133"><a href="#cb43-133" aria-hidden="true" tabindex="-1"></a>performs this conversion:</span>
<span id="cb43-134"><a href="#cb43-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-137"><a href="#cb43-137" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-138"><a href="#cb43-138" aria-hidden="true" tabindex="-1"></a>run_lengths <span class="ot">&lt;-</span> <span class="fu">rle</span>(myc)</span>
<span id="cb43-139"><a href="#cb43-139" aria-hidden="true" tabindex="-1"></a>run_lengths</span>
<span id="cb43-140"><a href="#cb43-140" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-141"><a href="#cb43-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-142"><a href="#cb43-142" aria-hidden="true" tabindex="-1"></a>and returns two components: </span>
<span id="cb43-143"><a href="#cb43-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-144"><a href="#cb43-144" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>a vector of values:</span>
<span id="cb43-145"><a href="#cb43-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-148"><a href="#cb43-148" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-149"><a href="#cb43-149" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(run_lengths<span class="sc">$</span>values)</span>
<span id="cb43-150"><a href="#cb43-150" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-151"><a href="#cb43-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-152"><a href="#cb43-152" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>a vector with the number of times each of them is repeated:</span>
<span id="cb43-153"><a href="#cb43-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-156"><a href="#cb43-156" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-157"><a href="#cb43-157" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(run_lengths<span class="sc">$</span>lengths)</span>
<span id="cb43-158"><a href="#cb43-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-159"><a href="#cb43-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-160"><a href="#cb43-160" aria-hidden="true" tabindex="-1"></a>This allows us to compress the original <span class="in">`r ncol(tenx_pbmc4k)`</span></span>
<span id="cb43-161"><a href="#cb43-161" aria-hidden="true" tabindex="-1"></a>integers into <span class="in">`r sum(lengths(run_lengths))`</span> integers </span>
<span id="cb43-162"><a href="#cb43-162" aria-hidden="true" tabindex="-1"></a>(<span class="in">`r lengths(run_lengths)[1]`</span> length &amp; value pairs), </span>
<span id="cb43-163"><a href="#cb43-163" aria-hidden="true" tabindex="-1"></a>without losing any information.</span>
<span id="cb43-164"><a href="#cb43-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-165"><a href="#cb43-165" aria-hidden="true" tabindex="-1"></a>By combining information about values and run-lengths, we can reconstruct</span>
<span id="cb43-166"><a href="#cb43-166" aria-hidden="true" tabindex="-1"></a>the original vector, either manually:</span>
<span id="cb43-167"><a href="#cb43-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-168"><a href="#cb43-168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-169"><a href="#cb43-169" aria-hidden="true" tabindex="-1"></a><span class="in">0 x 3: 0,0,0,</span></span>
<span id="cb43-170"><a href="#cb43-170" aria-hidden="true" tabindex="-1"></a><span class="in">1 x 1: 1,</span></span>
<span id="cb43-171"><a href="#cb43-171" aria-hidden="true" tabindex="-1"></a><span class="in">3 x 1: 3,</span></span>
<span id="cb43-172"><a href="#cb43-172" aria-hidden="true" tabindex="-1"></a><span class="in">0 x 3: 0,0,0,</span></span>
<span id="cb43-173"><a href="#cb43-173" aria-hidden="true" tabindex="-1"></a><span class="in">1 x 1: 1,</span></span>
<span id="cb43-174"><a href="#cb43-174" aria-hidden="true" tabindex="-1"></a><span class="in">0 x 4: 0,0,0,0,</span></span>
<span id="cb43-175"><a href="#cb43-175" aria-hidden="true" tabindex="-1"></a><span class="in">1 x 3: 1,1,1,</span></span>
<span id="cb43-176"><a href="#cb43-176" aria-hidden="true" tabindex="-1"></a><span class="in">...</span></span>
<span id="cb43-177"><a href="#cb43-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-178"><a href="#cb43-178" aria-hidden="true" tabindex="-1"></a><span class="in">=&gt; 0,0,0,1,3,0,0,0,1,0,0,0,0,1,1,1,...</span></span>
<span id="cb43-179"><a href="#cb43-179" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-180"><a href="#cb43-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-181"><a href="#cb43-181" aria-hidden="true" tabindex="-1"></a>or via <span class="in">`inverse.rle`</span>:</span>
<span id="cb43-182"><a href="#cb43-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-185"><a href="#cb43-185" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-186"><a href="#cb43-186" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">inverse.rle</span>(run_lengths), <span class="at">n =</span> <span class="dv">16</span>)</span>
<span id="cb43-187"><a href="#cb43-187" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-188"><a href="#cb43-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-189"><a href="#cb43-189" aria-hidden="true" tabindex="-1"></a>To store run-length encoded values e.g. in a text (or HTML) file, we can also</span>
<span id="cb43-190"><a href="#cb43-190" aria-hidden="true" tabindex="-1"></a>represent them as characters, similar to our manual reconstruction above, e.g.</span>
<span id="cb43-191"><a href="#cb43-191" aria-hidden="true" tabindex="-1"></a>separating values and lengths with an <span class="in">`x`</span>:</span>
<span id="cb43-192"><a href="#cb43-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-195"><a href="#cb43-195" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-196"><a href="#cb43-196" aria-hidden="true" tabindex="-1"></a>myc_rle_separated <span class="ot">&lt;-</span> <span class="fu">mapply</span>(paste, </span>
<span id="cb43-197"><a href="#cb43-197" aria-hidden="true" tabindex="-1"></a>    run_lengths<span class="sc">$</span>values, </span>
<span id="cb43-198"><a href="#cb43-198" aria-hidden="true" tabindex="-1"></a>    run_lengths<span class="sc">$</span>length, </span>
<span id="cb43-199"><a href="#cb43-199" aria-hidden="true" tabindex="-1"></a>    <span class="at">MoreArgs =</span> <span class="fu">list</span>(<span class="at">sep =</span> <span class="st">"x"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb43-200"><a href="#cb43-200" aria-hidden="true" tabindex="-1"></a>  <span class="fu">paste</span>(<span class="at">collapse =</span> <span class="st">";"</span>)</span>
<span id="cb43-201"><a href="#cb43-201" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(myc_rle_separated, <span class="dv">1</span>, <span class="dv">40</span>)</span>
<span id="cb43-202"><a href="#cb43-202" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-203"><a href="#cb43-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-204"><a href="#cb43-204" aria-hidden="true" tabindex="-1"></a>This representation occupies only </span>
<span id="cb43-205"><a href="#cb43-205" aria-hidden="true" tabindex="-1"></a><span class="in">`r format(object.size(myc_rle_separated), units = "KiB")`</span> of memory - but _half_</span>
<span id="cb43-206"><a href="#cb43-206" aria-hidden="true" tabindex="-1"></a>of the character string is required to encode the <span class="in">`x`</span> and <span class="in">`;`</span> separators. We</span>
<span id="cb43-207"><a href="#cb43-207" aria-hidden="true" tabindex="-1"></a>can do better!</span>
<span id="cb43-208"><a href="#cb43-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-209"><a href="#cb43-209" aria-hidden="true" tabindex="-1"></a>To avoid including any separators, we can represent one of the</span>
<span id="cb43-210"><a href="#cb43-210" aria-hidden="true" tabindex="-1"></a>numbers, e.g. the values, as a single character instead. For the _MYC_ gene, the </span>
<span id="cb43-211"><a href="#cb43-211" aria-hidden="true" tabindex="-1"></a>largest observed integer count is <span class="in">`r max(myc)`</span>. So let's represent all </span>
<span id="cb43-212"><a href="#cb43-212" aria-hidden="true" tabindex="-1"></a><span class="in">`r max(myc) + 1`</span> values (including 0) with a letter of the alphabet instead:</span>
<span id="cb43-213"><a href="#cb43-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-216"><a href="#cb43-216" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-217"><a href="#cb43-217" aria-hidden="true" tabindex="-1"></a>dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(letters[<span class="dv">1</span><span class="sc">:</span>(<span class="fu">max</span>(myc) <span class="sc">+</span> <span class="dv">1</span>)], <span class="dv">0</span><span class="sc">:</span><span class="fu">max</span>(myc))</span>
<span id="cb43-218"><a href="#cb43-218" aria-hidden="true" tabindex="-1"></a>dictionary</span>
<span id="cb43-219"><a href="#cb43-219" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-220"><a href="#cb43-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-221"><a href="#cb43-221" aria-hidden="true" tabindex="-1"></a>For example, the letter <span class="in">`a`</span> represents <span class="in">`0`</span>, <span class="in">`b`</span> represents <span class="in">`1`</span> and so on.</span>
<span id="cb43-222"><a href="#cb43-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-223"><a href="#cb43-223" aria-hidden="true" tabindex="-1"></a>Now we can omit the <span class="in">`x`</span> and <span class="in">`;`</span> separators, as each run is unambiguously</span>
<span id="cb43-224"><a href="#cb43-224" aria-hidden="true" tabindex="-1"></a>represented by one character and an integer <span class="ot">[^2]</span>:</span>
<span id="cb43-225"><a href="#cb43-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-228"><a href="#cb43-228" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-229"><a href="#cb43-229" aria-hidden="true" tabindex="-1"></a>myc_rle_character <span class="ot">&lt;-</span> <span class="fu">mapply</span>(paste0, </span>
<span id="cb43-230"><a href="#cb43-230" aria-hidden="true" tabindex="-1"></a>    dictionary[<span class="fu">as.character</span>(run_lengths<span class="sc">$</span>values)],  <span class="co"># &lt;1&gt;</span></span>
<span id="cb43-231"><a href="#cb43-231" aria-hidden="true" tabindex="-1"></a>    run_lengths<span class="sc">$</span>length) <span class="sc">|&gt;</span></span>
<span id="cb43-232"><a href="#cb43-232" aria-hidden="true" tabindex="-1"></a>  <span class="fu">paste</span>(<span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb43-233"><a href="#cb43-233" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(myc_rle_character, <span class="dv">1</span>, <span class="dv">21</span>)</span>
<span id="cb43-234"><a href="#cb43-234" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-235"><a href="#cb43-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-236"><a href="#cb43-236" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>It's critical to coerce the run-length values into a _character_ vector here,</span>
<span id="cb43-237"><a href="#cb43-237" aria-hidden="true" tabindex="-1"></a>otherwise the named vector is subset by _position_ instead of by _name_.</span>
<span id="cb43-238"><a href="#cb43-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-239"><a href="#cb43-239" aria-hidden="true" tabindex="-1"></a><span class="ot">[^2]: </span>Because runs can be very long, the lengths - represented as integers - </span>
<span id="cb43-240"><a href="#cb43-240" aria-hidden="true" tabindex="-1"></a>have varying number of decimals.</span>
<span id="cb43-241"><a href="#cb43-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-242"><a href="#cb43-242" aria-hidden="true" tabindex="-1"></a>In this representation, the <span class="in">`r ncol(tenx_pbmc4k)`</span> counts value for the _MYC_ </span>
<span id="cb43-243"><a href="#cb43-243" aria-hidden="true" tabindex="-1"></a>gene now occupy only <span class="in">`r format(object.size(myc_rle_character), units = "KiB")`</span> </span>
<span id="cb43-244"><a href="#cb43-244" aria-hidden="true" tabindex="-1"></a>of memory instead of the original <span class="in">`r format(object.size(myc), units = "KiB")`</span>.</span>
<span id="cb43-245"><a href="#cb43-245" aria-hidden="true" tabindex="-1"></a>We can also write the data to a text (or HTML) file in this format, e.g. as a </span>
<span id="cb43-246"><a href="#cb43-246" aria-hidden="true" tabindex="-1"></a>single string.</span>
<span id="cb43-247"><a href="#cb43-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-248"><a href="#cb43-248" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb43-249"><a href="#cb43-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-250"><a href="#cb43-250" aria-hidden="true" tabindex="-1"></a><span class="fu">### Encoding larger numbers of values</span></span>
<span id="cb43-251"><a href="#cb43-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-252"><a href="#cb43-252" aria-hidden="true" tabindex="-1"></a>In this example, we only needed <span class="in">`r max(myc) + 1`</span> letters to encode all observed</span>
<span id="cb43-253"><a href="#cb43-253" aria-hidden="true" tabindex="-1"></a>unique counts for the _MYC_ gene. But for other genes, especially those </span>
<span id="cb43-254"><a href="#cb43-254" aria-hidden="true" tabindex="-1"></a>expressed at higher levels, we might observe many more possible values - even</span>
<span id="cb43-255"><a href="#cb43-255" aria-hidden="true" tabindex="-1"></a>more than the <span class="in">`r length(letters)`</span> lower case letters of the English alphabet.</span>
<span id="cb43-256"><a href="#cb43-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-259"><a href="#cb43-259" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-260"><a href="#cb43-260" aria-hidden="true" tabindex="-1"></a>gapdh <span class="ot">&lt;-</span> <span class="fu">local</span>({</span>
<span id="cb43-261"><a href="#cb43-261" aria-hidden="true" tabindex="-1"></a>  ensembl <span class="ot">&lt;-</span> <span class="fu">row.names</span>(tenx_pbmc4k)[</span>
<span id="cb43-262"><a href="#cb43-262" aria-hidden="true" tabindex="-1"></a>    <span class="fu">which</span>(<span class="fu">rowData</span>(tenx_pbmc4k)<span class="sc">$</span>Symbol <span class="sc">==</span> <span class="st">"GAPDH"</span>)]</span>
<span id="cb43-263"><a href="#cb43-263" aria-hidden="true" tabindex="-1"></a>  <span class="fu">counts</span>(tenx_pbmc4k)[ensembl, ]</span>
<span id="cb43-264"><a href="#cb43-264" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb43-265"><a href="#cb43-265" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-266"><a href="#cb43-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-267"><a href="#cb43-267" aria-hidden="true" tabindex="-1"></a>For example, in this dataset we observe <span class="in">`r length(table(gapdh))`</span> distinct</span>
<span id="cb43-268"><a href="#cb43-268" aria-hidden="true" tabindex="-1"></a>count values for the highly abundant _GAPDH_ gene:</span>
<span id="cb43-269"><a href="#cb43-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-272"><a href="#cb43-272" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-273"><a href="#cb43-273" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(gapdh)</span>
<span id="cb43-274"><a href="#cb43-274" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-275"><a href="#cb43-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-276"><a href="#cb43-276" aria-hidden="true" tabindex="-1"></a>Luckily, we are not restricted to the English alphabet. For example, we can map</span>
<span id="cb43-277"><a href="#cb43-277" aria-hidden="true" tabindex="-1"></a>to any character in the </span>
<span id="cb43-278"><a href="#cb43-278" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Unicode Transformation Format – 8-bit (UTF-8)</span><span class="co">](https://en.wikipedia.org/wiki/UTF-8)</span></span>
<span id="cb43-279"><a href="#cb43-279" aria-hidden="true" tabindex="-1"></a>character encoding instead.</span>
<span id="cb43-280"><a href="#cb43-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-281"><a href="#cb43-281" aria-hidden="true" tabindex="-1"></a>To encode e.g. all integers from 1 to 256 (more than enough for _GAPDH_) - but</span>
<span id="cb43-282"><a href="#cb43-282" aria-hidden="true" tabindex="-1"></a>*avoiding those that represent a space, quote, etc or integers* - </span>
<span id="cb43-283"><a href="#cb43-283" aria-hidden="true" tabindex="-1"></a>we can use UTF-8 codes 64 to 319:</span>
<span id="cb43-284"><a href="#cb43-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-287"><a href="#cb43-287" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-288"><a href="#cb43-288" aria-hidden="true" tabindex="-1"></a>codes <span class="ot">&lt;-</span> <span class="dv">64</span><span class="sc">:</span><span class="dv">319</span></span>
<span id="cb43-289"><a href="#cb43-289" aria-hidden="true" tabindex="-1"></a>dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">intToUtf8</span>(codes, <span class="at">multiple =</span> <span class="cn">TRUE</span>), <span class="dv">0</span><span class="sc">:</span><span class="dv">255</span>)</span>
<span id="cb43-290"><a href="#cb43-290" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(dictionary, <span class="at">n =</span> <span class="dv">66</span>)</span>
<span id="cb43-291"><a href="#cb43-291" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-292"><a href="#cb43-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-293"><a href="#cb43-293" aria-hidden="true" tabindex="-1"></a>And then use this dictionary to encode the _GAPDH_ counts:</span>
<span id="cb43-294"><a href="#cb43-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-297"><a href="#cb43-297" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-298"><a href="#cb43-298" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(gapdh, <span class="at">n =</span> <span class="dv">20</span>)</span>
<span id="cb43-299"><a href="#cb43-299" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-300"><a href="#cb43-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-303"><a href="#cb43-303" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb43-304"><a href="#cb43-304" aria-hidden="true" tabindex="-1"></a>gapdh_character <span class="ot">&lt;-</span> <span class="fu">local</span>({</span>
<span id="cb43-305"><a href="#cb43-305" aria-hidden="true" tabindex="-1"></a>  run_lengths <span class="ot">&lt;-</span> <span class="fu">rle</span>(gapdh)</span>
<span id="cb43-306"><a href="#cb43-306" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapply</span>(paste0, </span>
<span id="cb43-307"><a href="#cb43-307" aria-hidden="true" tabindex="-1"></a>         dictionary[<span class="fu">as.character</span>(run_lengths<span class="sc">$</span>values)],</span>
<span id="cb43-308"><a href="#cb43-308" aria-hidden="true" tabindex="-1"></a>         run_lengths<span class="sc">$</span>length) <span class="sc">|&gt;</span></span>
<span id="cb43-309"><a href="#cb43-309" aria-hidden="true" tabindex="-1"></a>    <span class="fu">paste0</span>(<span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb43-310"><a href="#cb43-310" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb43-311"><a href="#cb43-311" aria-hidden="true" tabindex="-1"></a><span class="fu">substr</span>(gapdh_character, <span class="dv">1</span>, <span class="dv">36</span>)</span>
<span id="cb43-312"><a href="#cb43-312" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-313"><a href="#cb43-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-314"><a href="#cb43-314" aria-hidden="true" tabindex="-1"></a>Because there are more (and shorter) runs in the _GAPDH_ count vector than</span>
<span id="cb43-315"><a href="#cb43-315" aria-hidden="true" tabindex="-1"></a>for _MYC_, the degree of compression we achieve is smaller, from </span>
<span id="cb43-316"><a href="#cb43-316" aria-hidden="true" tabindex="-1"></a><span class="in">`r format(object.size(gapdh), units = "KiB")`</span> for the original count vector to </span>
<span id="cb43-317"><a href="#cb43-317" aria-hidden="true" tabindex="-1"></a><span class="in">`r format(object.size(gapdh_character), units = "KiB")`</span> for the character</span>
<span id="cb43-318"><a href="#cb43-318" aria-hidden="true" tabindex="-1"></a>representation.</span>
<span id="cb43-319"><a href="#cb43-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-320"><a href="#cb43-320" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb43-321"><a href="#cb43-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-322"><a href="#cb43-322" aria-hidden="true" tabindex="-1"></a>::: {.callout-caution collapse="true"}</span>
<span id="cb43-323"><a href="#cb43-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-324"><a href="#cb43-324" aria-hidden="true" tabindex="-1"></a>In this post, the example dictionaries encode counts up to 256 - but many</span>
<span id="cb43-325"><a href="#cb43-325" aria-hidden="true" tabindex="-1"></a>single-cell experiments will contain larger integer counts than 256. </span>
<span id="cb43-326"><a href="#cb43-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-327"><a href="#cb43-327" aria-hidden="true" tabindex="-1"></a>For those, we either need to create a  larger dictionary, or we could opt to</span>
<span id="cb43-328"><a href="#cb43-328" aria-hidden="true" tabindex="-1"></a>truncate larger values (e.g. represent counts &gt;= 256 with the same character,</span>
<span id="cb43-329"><a href="#cb43-329" aria-hidden="true" tabindex="-1"></a>losing information in the process).</span>
<span id="cb43-330"><a href="#cb43-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-331"><a href="#cb43-331" aria-hidden="true" tabindex="-1"></a>When visualizing gene expression scores, we often log2 transform the raw or</span>
<span id="cb43-332"><a href="#cb43-332" aria-hidden="true" tabindex="-1"></a>normalized counts, generating floating point numbers. If it is acceptable to</span>
<span id="cb43-333"><a href="#cb43-333" aria-hidden="true" tabindex="-1"></a>lose precision, we can round these log2 transformed scores to the nearest</span>
<span id="cb43-334"><a href="#cb43-334" aria-hidden="true" tabindex="-1"></a>integer and apply run-length encoding to them.</span>
<span id="cb43-335"><a href="#cb43-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-336"><a href="#cb43-336" aria-hidden="true" tabindex="-1"></a>Because 2 to the power of 256 is a very large number (~ 1.16e+77), we would</span>
<span id="cb43-337"><a href="#cb43-337" aria-hidden="true" tabindex="-1"></a>be able to represent even the highest observed scores But on the flip side,</span>
<span id="cb43-338"><a href="#cb43-338" aria-hidden="true" tabindex="-1"></a>rounding the log2 transformed scores would obscure some differences between</span>
<span id="cb43-339"><a href="#cb43-339" aria-hidden="true" tabindex="-1"></a>expression levels.</span>
<span id="cb43-340"><a href="#cb43-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-341"><a href="#cb43-341" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb43-342"><a href="#cb43-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-343"><a href="#cb43-343" aria-hidden="true" tabindex="-1"></a><span class="fu">## LZW compression</span></span>
<span id="cb43-344"><a href="#cb43-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-345"><a href="#cb43-345" aria-hidden="true" tabindex="-1"></a>At this point, we are representing the original count vectors as character</span>
<span id="cb43-346"><a href="#cb43-346" aria-hidden="true" tabindex="-1"></a>strings. Some of these string representation contain repeated patterns, which</span>
<span id="cb43-347"><a href="#cb43-347" aria-hidden="true" tabindex="-1"></a>we can exploit to compress them even further.</span>
<span id="cb43-348"><a href="#cb43-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-349"><a href="#cb43-349" aria-hidden="true" tabindex="-1"></a>::: {.callout-note collapse="true"}</span>
<span id="cb43-350"><a href="#cb43-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-351"><a href="#cb43-351" aria-hidden="true" tabindex="-1"></a>The <span class="in">`Lempel–Ziv–Welch`</span> algorithm was the </span>
<span id="cb43-352"><a href="#cb43-352" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">first widely used universal data compression method</span><span class="co">](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)</span></span>
<span id="cb43-353"><a href="#cb43-353" aria-hidden="true" tabindex="-1"></a>and is e.g. used in the GIF image format. </span>
<span id="cb43-354"><a href="#cb43-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-355"><a href="#cb43-355" aria-hidden="true" tabindex="-1"></a>At a high level, the algorithm identifies the longest repeated sequences</span>
<span id="cb43-356"><a href="#cb43-356" aria-hidden="true" tabindex="-1"></a>("phrases") in a character string and maps them to shorter expressions in a</span>
<span id="cb43-357"><a href="#cb43-357" aria-hidden="true" tabindex="-1"></a>dictionary. </span>
<span id="cb43-358"><a href="#cb43-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-359"><a href="#cb43-359" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb43-360"><a href="#cb43-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-361"><a href="#cb43-361" aria-hidden="true" tabindex="-1"></a>There are great tutorials about the LZW algorithm and its implementation</span>
<span id="cb43-362"><a href="#cb43-362" aria-hidden="true" tabindex="-1"></a>available on the web, e.g. </span>
<span id="cb43-363"><a href="#cb43-363" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">this one</span><span class="co">]</span>(https://eng.libretexts.org/Bookshelves/Electrical_Engineering/Signal_Processing_and_Modeling/Information_and_Entropy_(Penfield)/03%3A_Compression/3.07%3A_Detail-_LZW_Compression/3.7.01%3A_LZW_Algorithm_Example_1). </span>
<span id="cb43-364"><a href="#cb43-364" aria-hidden="true" tabindex="-1"></a>Here, I will create a basic implementation in R <span class="ot">[^3]</span>. </span>
<span id="cb43-365"><a href="#cb43-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-366"><a href="#cb43-366" aria-hidden="true" tabindex="-1"></a><span class="ot">[^3]: </span>While this implementation works, it could be improved. For example, it </span>
<span id="cb43-367"><a href="#cb43-367" aria-hidden="true" tabindex="-1"></a>doesn't set any limits on the size of the final dictionary.</span>
<span id="cb43-368"><a href="#cb43-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-369"><a href="#cb43-369" aria-hidden="true" tabindex="-1"></a><span class="fu">### LZW encoding</span></span>
<span id="cb43-370"><a href="#cb43-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-373"><a href="#cb43-373" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-374"><a href="#cb43-374" aria-hidden="true" tabindex="-1"></a>compress_lzw <span class="ot">&lt;-</span> <span class="cf">function</span>(input_string) {</span>
<span id="cb43-375"><a href="#cb43-375" aria-hidden="true" tabindex="-1"></a>  dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>),   <span class="co"># &lt;1&gt;</span></span>
<span id="cb43-376"><a href="#cb43-376" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>)</span>
<span id="cb43-377"><a href="#cb43-377" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb43-378"><a href="#cb43-378" aria-hidden="true" tabindex="-1"></a>  next_code <span class="ot">&lt;-</span> <span class="dv">257</span></span>
<span id="cb43-379"><a href="#cb43-379" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb43-380"><a href="#cb43-380" aria-hidden="true" tabindex="-1"></a>  previous_pattern <span class="ot">&lt;-</span> <span class="fu">character</span>(<span class="dv">0</span>)  <span class="co"># &lt;2&gt;</span></span>
<span id="cb43-381"><a href="#cb43-381" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> <span class="fu">character</span>(<span class="dv">0</span>)  <span class="co"># &lt;3&gt;</span></span>
<span id="cb43-382"><a href="#cb43-382" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb43-383"><a href="#cb43-383" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (char <span class="cf">in</span> <span class="fu">strsplit</span>(input_string, <span class="st">""</span>)[[<span class="dv">1</span>]]) {  <span class="co"># &lt;4&gt;</span></span>
<span id="cb43-384"><a href="#cb43-384" aria-hidden="true" tabindex="-1"></a>    new_pattern <span class="ot">&lt;-</span> <span class="fu">paste0</span>(previous_pattern, char)  <span class="co"># &lt;5&gt;</span></span>
<span id="cb43-385"><a href="#cb43-385" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (new_pattern <span class="sc">%in%</span> <span class="fu">names</span>(dictionary)) {  <span class="co"># &lt;6&gt;</span></span>
<span id="cb43-386"><a href="#cb43-386" aria-hidden="true" tabindex="-1"></a>      previous_pattern <span class="ot">&lt;-</span> new_pattern</span>
<span id="cb43-387"><a href="#cb43-387" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {  <span class="co"># &lt;7&gt; </span></span>
<span id="cb43-388"><a href="#cb43-388" aria-hidden="true" tabindex="-1"></a>      output <span class="ot">&lt;-</span> <span class="fu">paste0</span>(output, dictionary[[previous_pattern]])  <span class="co"># &lt;7&gt;</span></span>
<span id="cb43-389"><a href="#cb43-389" aria-hidden="true" tabindex="-1"></a>      dictionary[[new_pattern]] <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="fu">intToUtf8</span>(next_code))</span>
<span id="cb43-390"><a href="#cb43-390" aria-hidden="true" tabindex="-1"></a>      next_code <span class="ot">&lt;-</span> next_code <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb43-391"><a href="#cb43-391" aria-hidden="true" tabindex="-1"></a>      previous_pattern <span class="ot">&lt;-</span> char</span>
<span id="cb43-392"><a href="#cb43-392" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb43-393"><a href="#cb43-393" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb43-394"><a href="#cb43-394" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb43-395"><a href="#cb43-395" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">nzchar</span>(previous_pattern)) {</span>
<span id="cb43-396"><a href="#cb43-396" aria-hidden="true" tabindex="-1"></a>    output <span class="ot">&lt;-</span> <span class="fu">paste0</span>(output, dictionary[[previous_pattern]]) <span class="co"># &lt;8&gt;</span></span>
<span id="cb43-397"><a href="#cb43-397" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb43-398"><a href="#cb43-398" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(output)</span>
<span id="cb43-399"><a href="#cb43-399" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-400"><a href="#cb43-400" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-401"><a href="#cb43-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-402"><a href="#cb43-402" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>We initialize a "dictionary" (e.g. a named character vector) with 256 UTF-8</span>
<span id="cb43-403"><a href="#cb43-403" aria-hidden="true" tabindex="-1"></a>codes.</span>
<span id="cb43-404"><a href="#cb43-404" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>As we parse the input string, the current sequence will be stored in the </span>
<span id="cb43-405"><a href="#cb43-405" aria-hidden="true" tabindex="-1"></a><span class="in">`previous_pattern`</span> variable. It is initialized as an empty string.</span>
<span id="cb43-406"><a href="#cb43-406" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>The <span class="in">`output`</span> variable will collect the compressed output and is </span>
<span id="cb43-407"><a href="#cb43-407" aria-hidden="true" tabindex="-1"></a>eventually returned. It is also initialized as an empty string.</span>
<span id="cb43-408"><a href="#cb43-408" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>The input string is split into individual characters, and we process them</span>
<span id="cb43-409"><a href="#cb43-409" aria-hidden="true" tabindex="-1"></a>one by one.</span>
<span id="cb43-410"><a href="#cb43-410" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>In the first loop, the <span class="in">`previous_pattern`</span> is still empty. But in subsequent</span>
<span id="cb43-411"><a href="#cb43-411" aria-hidden="true" tabindex="-1"></a>loops, we extend the previous one with the new character to identify longer</span>
<span id="cb43-412"><a href="#cb43-412" aria-hidden="true" tabindex="-1"></a>patterns.</span>
<span id="cb43-413"><a href="#cb43-413" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>If the extended pattern is already known, then we don't need to update our</span>
<span id="cb43-414"><a href="#cb43-414" aria-hidden="true" tabindex="-1"></a>dictionary. We simply replace the <span class="in">`previous_pattern`</span> with the current one.</span>
<span id="cb43-415"><a href="#cb43-415" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>If we encounter a _new_ pattern, then we </span>
<span id="cb43-416"><a href="#cb43-416" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Encode the <span class="in">`previous_pattern`</span> and add it to the output</span>
<span id="cb43-417"><a href="#cb43-417" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Map the new pattern to the next available UTF-8 code</span>
<span id="cb43-418"><a href="#cb43-418" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Increment the position of the next available UTF-8 code by one</span>
<span id="cb43-419"><a href="#cb43-419" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Reset the previous pattern to the current character.</span>
<span id="cb43-420"><a href="#cb43-420" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>After the entire string has been processed, we encode the final pattern</span>
<span id="cb43-421"><a href="#cb43-421" aria-hidden="true" tabindex="-1"></a>and then return the full output.</span>
<span id="cb43-422"><a href="#cb43-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-423"><a href="#cb43-423" aria-hidden="true" tabindex="-1"></a>Let's apply our LZW compression function to the run-length encoded _MYC_</span>
<span id="cb43-424"><a href="#cb43-424" aria-hidden="true" tabindex="-1"></a>expression we generated above:</span>
<span id="cb43-425"><a href="#cb43-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-428"><a href="#cb43-428" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-429"><a href="#cb43-429" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb43-430"><a href="#cb43-430" aria-hidden="true" tabindex="-1"></a>myc_lzw <span class="ot">&lt;-</span> <span class="fu">compress_lzw</span>(myc_rle_character)</span>
<span id="cb43-431"><a href="#cb43-431" aria-hidden="true" tabindex="-1"></a>myc_lzw</span>
<span id="cb43-432"><a href="#cb43-432" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-433"><a href="#cb43-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-434"><a href="#cb43-434" aria-hidden="true" tabindex="-1"></a>After LZW compression, R estimates the size of this new character representation</span>
<span id="cb43-435"><a href="#cb43-435" aria-hidden="true" tabindex="-1"></a>to be <span class="in">`r format(object.size(myc_lzw), units = "KiB")`</span>, down from </span>
<span id="cb43-436"><a href="#cb43-436" aria-hidden="true" tabindex="-1"></a><span class="in">`r format(object.size(myc_rle_character), units = "KiB")`</span> after RLE.</span>
<span id="cb43-437"><a href="#cb43-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-438"><a href="#cb43-438" aria-hidden="true" tabindex="-1"></a>Next, let's implement the corresponding decoding function!</span>
<span id="cb43-439"><a href="#cb43-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-440"><a href="#cb43-440" aria-hidden="true" tabindex="-1"></a><span class="fu">### LZW decoding</span></span>
<span id="cb43-441"><a href="#cb43-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-444"><a href="#cb43-444" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-445"><a href="#cb43-445" aria-hidden="true" tabindex="-1"></a>decompress_lzw <span class="ot">&lt;-</span> <span class="cf">function</span>(compressed) {</span>
<span id="cb43-446"><a href="#cb43-446" aria-hidden="true" tabindex="-1"></a>  dictionary <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>),   <span class="co"># &lt;1&gt;</span></span>
<span id="cb43-447"><a href="#cb43-447" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">intToUtf8</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">256</span>, <span class="at">multiple =</span> <span class="cn">TRUE</span>)</span>
<span id="cb43-448"><a href="#cb43-448" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb43-449"><a href="#cb43-449" aria-hidden="true" tabindex="-1"></a>  next_code <span class="ot">&lt;-</span> <span class="dv">257</span></span>
<span id="cb43-450"><a href="#cb43-450" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb43-451"><a href="#cb43-451" aria-hidden="true" tabindex="-1"></a>  compressed_codes <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(compressed, <span class="st">""</span>)[[<span class="dv">1</span>]]  <span class="co"># &lt;2&gt;</span></span>
<span id="cb43-452"><a href="#cb43-452" aria-hidden="true" tabindex="-1"></a>  <span class="co"># read the first character and decode it</span></span>
<span id="cb43-453"><a href="#cb43-453" aria-hidden="true" tabindex="-1"></a>  current_code <span class="ot">&lt;-</span> compressed_codes[<span class="dv">1</span>]  <span class="co"># &lt;3&gt;</span></span>
<span id="cb43-454"><a href="#cb43-454" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> dictionary[[current_code]] </span>
<span id="cb43-455"><a href="#cb43-455" aria-hidden="true" tabindex="-1"></a>  previous_string <span class="ot">&lt;-</span> output</span>
<span id="cb43-456"><a href="#cb43-456" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb43-457"><a href="#cb43-457" aria-hidden="true" tabindex="-1"></a>  <span class="co"># read the remaining characters, one by one</span></span>
<span id="cb43-458"><a href="#cb43-458" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (code <span class="cf">in</span> compressed_codes[<span class="sc">-</span><span class="dv">1</span>]) {  <span class="co"># &lt;4&gt;</span></span>
<span id="cb43-459"><a href="#cb43-459" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">as.character</span>(code) <span class="sc">%in%</span> <span class="fu">names</span>(dictionary)) {</span>
<span id="cb43-460"><a href="#cb43-460" aria-hidden="true" tabindex="-1"></a>      current_string <span class="ot">&lt;-</span> dictionary[<span class="fu">as.character</span>(code)]  <span class="co"># &lt;5&gt;</span></span>
<span id="cb43-461"><a href="#cb43-461" aria-hidden="true" tabindex="-1"></a>      dictionary[[<span class="fu">intToUtf8</span>(next_code)]] <span class="ot">&lt;-</span> <span class="fu">paste0</span>(previous_string, </span>
<span id="cb43-462"><a href="#cb43-462" aria-hidden="true" tabindex="-1"></a>                                                   <span class="fu">substr</span>(current_string, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb43-463"><a href="#cb43-463" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb43-464"><a href="#cb43-464" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb43-465"><a href="#cb43-465" aria-hidden="true" tabindex="-1"></a>      current_string <span class="ot">&lt;-</span> <span class="fu">paste0</span>(previous_string, <span class="fu">substr</span>(previous_string, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb43-466"><a href="#cb43-466" aria-hidden="true" tabindex="-1"></a>      dictionary[[<span class="fu">intToUtf8</span>(next_code)]] <span class="ot">&lt;-</span> current_string</span>
<span id="cb43-467"><a href="#cb43-467" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb43-468"><a href="#cb43-468" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb43-469"><a href="#cb43-469" aria-hidden="true" tabindex="-1"></a>    output <span class="ot">&lt;-</span> <span class="fu">paste0</span>(output, current_string)  <span class="co"># &lt;6&gt;</span></span>
<span id="cb43-470"><a href="#cb43-470" aria-hidden="true" tabindex="-1"></a>    next_code <span class="ot">&lt;-</span> next_code <span class="sc">+</span> <span class="dv">1</span>  <span class="co"># &lt;7&gt;</span></span>
<span id="cb43-471"><a href="#cb43-471" aria-hidden="true" tabindex="-1"></a>    previous_string <span class="ot">&lt;-</span> current_string  <span class="co"># &lt;8&gt;</span></span>
<span id="cb43-472"><a href="#cb43-472" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb43-473"><a href="#cb43-473" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(output)</span>
<span id="cb43-474"><a href="#cb43-474" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-475"><a href="#cb43-475" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-476"><a href="#cb43-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-477"><a href="#cb43-477" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The decoding function is provided with the same initial dictionary we</span>
<span id="cb43-478"><a href="#cb43-478" aria-hidden="true" tabindex="-1"></a>included in the encoding function.</span>
<span id="cb43-479"><a href="#cb43-479" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>We process the compressed string one character at a time.</span>
<span id="cb43-480"><a href="#cb43-480" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>The algorithm is initialized with the first character of the encoded string, </span>
<span id="cb43-481"><a href="#cb43-481" aria-hidden="true" tabindex="-1"></a>and we decode it using the pre-defined dictionary (which includes all single</span>
<span id="cb43-482"><a href="#cb43-482" aria-hidden="true" tabindex="-1"></a>characters).</span>
<span id="cb43-483"><a href="#cb43-483" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>We then iterate over the remaining characters in the compressed input.</span>
<span id="cb43-484"><a href="#cb43-484" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>We check if the current code is already in our dictionary</span>
<span id="cb43-485"><a href="#cb43-485" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>If _yes_, then we decode it by looking up its corresponding value in our</span>
<span id="cb43-486"><a href="#cb43-486" aria-hidden="true" tabindex="-1"></a>    dictionary. We also add an extended pattern to our dictionary, by</span>
<span id="cb43-487"><a href="#cb43-487" aria-hidden="true" tabindex="-1"></a>    concatenating the previous result with the (first character of) our </span>
<span id="cb43-488"><a href="#cb43-488" aria-hidden="true" tabindex="-1"></a>    current one.</span>
<span id="cb43-489"><a href="#cb43-489" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>If _no_, then we decode it by extending the previous result by its (own)</span>
<span id="cb43-490"><a href="#cb43-490" aria-hidden="true" tabindex="-1"></a>  first character and add it to the dictionary.</span>
<span id="cb43-491"><a href="#cb43-491" aria-hidden="true" tabindex="-1"></a>  character </span>
<span id="cb43-492"><a href="#cb43-492" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>We add the newly decoded result to our output string.</span>
<span id="cb43-493"><a href="#cb43-493" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>Increment the running index of our dictionary, because we added a new key.</span>
<span id="cb43-494"><a href="#cb43-494" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>Get ready for the next iteration.</span>
<span id="cb43-495"><a href="#cb43-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-496"><a href="#cb43-496" aria-hidden="true" tabindex="-1"></a>Let's test the function by restoring the RLE-encoded _MYC_ counts we</span>
<span id="cb43-497"><a href="#cb43-497" aria-hidden="true" tabindex="-1"></a>compressed above:</span>
<span id="cb43-498"><a href="#cb43-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-501"><a href="#cb43-501" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-502"><a href="#cb43-502" aria-hidden="true" tabindex="-1"></a>myc_lzw_decompressed <span class="ot">&lt;-</span> <span class="fu">decompress_lzw</span>(myc_lzw)</span>
<span id="cb43-503"><a href="#cb43-503" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(myc_lzw_decompressed)</span>
<span id="cb43-504"><a href="#cb43-504" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-505"><a href="#cb43-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-506"><a href="#cb43-506" aria-hidden="true" tabindex="-1"></a>Are the results of sequention compression &amp; decompression really identical</span>
<span id="cb43-507"><a href="#cb43-507" aria-hidden="true" tabindex="-1"></a>to the input string?</span>
<span id="cb43-508"><a href="#cb43-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-511"><a href="#cb43-511" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-512"><a href="#cb43-512" aria-hidden="true" tabindex="-1"></a><span class="fu">identical</span>(</span>
<span id="cb43-513"><a href="#cb43-513" aria-hidden="true" tabindex="-1"></a>  <span class="fu">decompress_lzw</span>(<span class="fu">compress_lzw</span>(myc_rle_character)), </span>
<span id="cb43-514"><a href="#cb43-514" aria-hidden="true" tabindex="-1"></a>  myc_rle_character)</span>
<span id="cb43-515"><a href="#cb43-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-516"><a href="#cb43-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-517"><a href="#cb43-517" aria-hidden="true" tabindex="-1"></a>::: {.callout-note collapse="true"}</span>
<span id="cb43-518"><a href="#cb43-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-519"><a href="#cb43-519" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Compression / decompression example</span></span>
<span id="cb43-520"><a href="#cb43-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-521"><a href="#cb43-521" aria-hidden="true" tabindex="-1"></a>Because it's hard to visually compare the long vectors we have compressed &amp; </span>
<span id="cb43-522"><a href="#cb43-522" aria-hidden="true" tabindex="-1"></a>decompressed above, here is a toy example:</span>
<span id="cb43-523"><a href="#cb43-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-526"><a href="#cb43-526" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-527"><a href="#cb43-527" aria-hidden="true" tabindex="-1"></a>original_string <span class="ot">&lt;-</span> <span class="st">"MARYHADALITTLELAMBMARYHADALITTLELAMBMARYHAD"</span></span>
<span id="cb43-528"><a href="#cb43-528" aria-hidden="true" tabindex="-1"></a>compressed <span class="ot">&lt;-</span> <span class="fu">compress_lzw</span>(original_string)</span>
<span id="cb43-529"><a href="#cb43-529" aria-hidden="true" tabindex="-1"></a>decompressed <span class="ot">&lt;-</span> <span class="fu">decompress_lzw</span>(compressed)</span>
<span id="cb43-530"><a href="#cb43-530" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-531"><a href="#cb43-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-534"><a href="#cb43-534" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-535"><a href="#cb43-535" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb43-536"><a href="#cb43-536" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Original String: "</span>, original_string, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb43-537"><a href="#cb43-537" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-538"><a href="#cb43-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-541"><a href="#cb43-541" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-542"><a href="#cb43-542" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb43-543"><a href="#cb43-543" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Compressed: "</span>, compressed, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb43-544"><a href="#cb43-544" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-545"><a href="#cb43-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-548"><a href="#cb43-548" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-549"><a href="#cb43-549" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb43-550"><a href="#cb43-550" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Decompressed: "</span>, decompressed, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb43-551"><a href="#cb43-551" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-552"><a href="#cb43-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-553"><a href="#cb43-553" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb43-554"><a href="#cb43-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-555"><a href="#cb43-555" aria-hidden="true" tabindex="-1"></a><span class="fu">## So what?</span></span>
<span id="cb43-556"><a href="#cb43-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-557"><a href="#cb43-557" aria-hidden="true" tabindex="-1"></a>We have applied two rounds of compression to our count (or rounded, log2 </span>
<span id="cb43-558"><a href="#cb43-558" aria-hidden="true" tabindex="-1"></a>transformed counts) single-cell RNA-seq data, achieving considerable reduction</span>
<span id="cb43-559"><a href="#cb43-559" aria-hidden="true" tabindex="-1"></a>in the size of the objects <span class="ot">[^4]</span>.</span>
<span id="cb43-560"><a href="#cb43-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-561"><a href="#cb43-561" aria-hidden="true" tabindex="-1"></a><span class="ot">[^4]: </span>Typical file formats used to exchange single-cell RNA-seq count tables</span>
<span id="cb43-562"><a href="#cb43-562" aria-hidden="true" tabindex="-1"></a>are using more sophisticated ways of compression. For example, applying</span>
<span id="cb43-563"><a href="#cb43-563" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">gzip compression</span><span class="co">](https://en.wikipedia.org/wiki/Gzip)</span> to CSV files with</span>
<span id="cb43-564"><a href="#cb43-564" aria-hidden="true" tabindex="-1"></a>sparse count data will reduce their sizes tremendously. Other formats, e.g. </span>
<span id="cb43-565"><a href="#cb43-565" aria-hidden="true" tabindex="-1"></a><span class="in">`HDF5`</span> or <span class="in">`Parquet`</span> files also take advantage of compression algorithms.</span>
<span id="cb43-566"><a href="#cb43-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-567"><a href="#cb43-567" aria-hidden="true" tabindex="-1"></a>While I have created examples of RLE and LZW compression using R, the same</span>
<span id="cb43-568"><a href="#cb43-568" aria-hidden="true" tabindex="-1"></a>approach can be implemented in any programming language. The reports generated</span>
<span id="cb43-569"><a href="#cb43-569" aria-hidden="true" tabindex="-1"></a>by Parse Bioscience, for example </span>
<span id="cb43-570"><a href="#cb43-570" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">this one</span><span class="co">](https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#)</span>,</span>
<span id="cb43-571"><a href="#cb43-571" aria-hidden="true" tabindex="-1"></a>include rounded log2 gene expression counts for all assayed genes across all</span>
<span id="cb43-572"><a href="#cb43-572" aria-hidden="true" tabindex="-1"></a>cells that was compressed in the same way <span class="ot">[^5]</span>. To decode the compressed </span>
<span id="cb43-573"><a href="#cb43-573" aria-hidden="true" tabindex="-1"></a>strings, the html reports include javascript functions that perform the same</span>
<span id="cb43-574"><a href="#cb43-574" aria-hidden="true" tabindex="-1"></a>operations established here.</span>
<span id="cb43-575"><a href="#cb43-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-576"><a href="#cb43-576" aria-hidden="true" tabindex="-1"></a><span class="ot">[^5]: </span>The encoding &amp; compression is happening when the report is generated,</span>
<span id="cb43-577"><a href="#cb43-577" aria-hidden="true" tabindex="-1"></a>but the decoding javascript functions are part of the HTML report.</span>
<span id="cb43-578"><a href="#cb43-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-579"><a href="#cb43-579" aria-hidden="true" tabindex="-1"></a>Combined with interactive plots, users can enter a gene name, triggering the</span>
<span id="cb43-580"><a href="#cb43-580" aria-hidden="true" tabindex="-1"></a>decoding of its gene expression scores and updating a UMP plot in their</span>
<span id="cb43-581"><a href="#cb43-581" aria-hidden="true" tabindex="-1"></a>browser - without the need for any central server. (Take a look at </span>
<span id="cb43-582"><a href="#cb43-582" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">the source code of one of their reports</span><span class="co">](https://cdn.parsebiosciences.com/mouse/brain-nuclei/v3/all-sample_analysis_summary.html#)</span></span>
<span id="cb43-583"><a href="#cb43-583" aria-hidden="true" tabindex="-1"></a>to see how this is achieved!)</span>
<span id="cb43-584"><a href="#cb43-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-585"><a href="#cb43-585" aria-hidden="true" tabindex="-1"></a>Now that I have a better understanding of how large amounts of data can be</span>
<span id="cb43-586"><a href="#cb43-586" aria-hidden="true" tabindex="-1"></a>included in a stand-along HTML document, I am ready to learn more about </span>
<span id="cb43-587"><a href="#cb43-587" aria-hidden="true" tabindex="-1"></a>javascript &amp; interactive visualizations <span class="ot">[^6]</span>! </span>
<span id="cb43-588"><a href="#cb43-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-589"><a href="#cb43-589" aria-hidden="true" tabindex="-1"></a><span class="ot">[^6]: </span>Greg Wilson's </span>
<span id="cb43-590"><a href="#cb43-590" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Javascript for Data Scientists</span><span class="co">](https://third-bit.com/js4ds/)</span></span>
<span id="cb43-591"><a href="#cb43-591" aria-hidden="true" tabindex="-1"></a>course has been on my to-do list for a while.</span>
<span id="cb43-592"><a href="#cb43-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-593"><a href="#cb43-593" aria-hidden="true" tabindex="-1"></a><span class="fu">## Reproducibility</span></span>
<span id="cb43-594"><a href="#cb43-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-595"><a href="#cb43-595" aria-hidden="true" tabindex="-1"></a>&lt;details&gt;</span>
<span id="cb43-596"><a href="#cb43-596" aria-hidden="true" tabindex="-1"></a>&lt;summary&gt;</span>
<span id="cb43-597"><a href="#cb43-597" aria-hidden="true" tabindex="-1"></a>Session Information</span>
<span id="cb43-598"><a href="#cb43-598" aria-hidden="true" tabindex="-1"></a>&lt;/summary&gt;</span>
<span id="cb43-599"><a href="#cb43-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-602"><a href="#cb43-602" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb43-603"><a href="#cb43-603" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span>
<span id="cb43-604"><a href="#cb43-604" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb43-605"><a href="#cb43-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-606"><a href="#cb43-606" aria-hidden="true" tabindex="-1"></a>&lt;/details&gt;</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>